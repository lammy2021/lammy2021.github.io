<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>00x2 中小型网络系统总体规划与设计方法</title>
    <link href="/2024/07/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%89%E7%BA%A7%E7%BD%91%E7%BB%9C%E6%8A%80%E6%9C%AF/00x2%20%E4%B8%AD%E5%B0%8F%E5%9E%8B%E7%BD%91%E7%BB%9C%E7%B3%BB%E7%BB%9F%E6%80%BB%E4%BD%93%E8%A7%84%E5%88%92%E4%B8%8E%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%B3%95/"/>
    <url>/2024/07/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%89%E7%BA%A7%E7%BD%91%E7%BB%9C%E6%8A%80%E6%9C%AF/00x2%20%E4%B8%AD%E5%B0%8F%E5%9E%8B%E7%BD%91%E7%BB%9C%E7%B3%BB%E7%BB%9F%E6%80%BB%E4%BD%93%E8%A7%84%E5%88%92%E4%B8%8E%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h3 id="路由器的主要技术指标包括："><a href="#路由器的主要技术指标包括：" class="headerlink" title="路由器的主要技术指标包括："></a>路由器的主要技术指标包括：</h3><p>1、吞吐量：指<u>包转发能力</u>，涉及两个内容–端口吞吐量和整机吞吐量，与<strong>路由器端口数量</strong>、<strong>端口速率</strong>、<strong>包长度</strong>、<strong>包类型</strong>有关。<br>2、背板能力：是<u>路由器输入输出的物理通道</u>，高性能路由器采用<strong>交换式</strong>结构，决定着<strong>路由器的吞吐量</strong>。<br>3、丢包率，衡量路由器<strong>超负荷工作能力的指标</strong>之一。<br>4、延时和延时抖动：高速路由器要求长度为1518B的IP包延时<strong>小于1ms</strong>，语音、视频业务对延时抖动要求较高。<br>5、突发处理能力：以<strong>最小帧间隔发送而不引起丢失的最大发送速率</strong>。<br>6、服务质量：表现在<strong>队列管理机制</strong>、<strong>端口硬件队列管理</strong>、<strong>支持QoS协议</strong>上，其中<u>队列管理机制指队列调度算法和拥塞管理机制</u>。<br>7、可靠性与可用性：无故障连续工作时间<strong>大于10万小时</strong>，系统故障恢复时间<strong>小于30分钟</strong>，所有的自动切换在<strong>50ms内</strong>完成。</p><h3 id="交换机总带宽的计算"><a href="#交换机总带宽的计算" class="headerlink" title="交换机总带宽的计算"></a>交换机总带宽的计算</h3><p>e.g</p><p>一台交换机具有48个10&#x2F;100Mbps端口和2个1000Mbps端口，如果所有端口都工作在全双工状态，那么交换机总带宽应为______。</p><blockquote><p>[!TIP]</p><p>交换机的总带宽等于各个端口带宽之和。如果是全双工端口的话，其端口带宽要按照2倍带宽计算。</p><p>对于诸如10&#x2F;100Mbps这样的10Mbps&#x2F;100Mbps自适应端口，其带宽按照最高速率计算。</p></blockquote><p>本题交换机的总带宽&#x3D;48<em>100</em>2+2<em>1000</em>2&#x3D;13.6Gbps</p><h3 id="服务器停机时间的计算"><a href="#服务器停机时间的计算" class="headerlink" title="服务器停机时间的计算"></a>服务器停机时间的计算</h3><p>若服务器系统可用性达到99.99%，那么每年的停机时间必须小于___53分钟___。</p><p>若服务器系统可用性达到99.999%，那么每年的停机时间必须小于等于___5分钟___。</p><h3 id="网络服务器的分类"><a href="#网络服务器的分类" class="headerlink" title="网络服务器的分类"></a>网络服务器的分类</h3><p>1、评价高性能存储技术的指标是存取I&#x2F;O速度与磁盘容量。<br>2、集群系统中一台主机出现故障，它所运行的程序将立即转移到其他主机，不会影响正常服务。<br>3、大中型服务器采用RISC，操作系统使用UNIX。<br>4、热插拔指不断电状态下插拔，但仅限于硬盘、板卡等外围设备，核心部件诸如内存、CPU、主板则不允许。</p><h3 id="汇聚层网络与接入层网络结构设计"><a href="#汇聚层网络与接入层网络结构设计" class="headerlink" title="汇聚层网络与接入层网络结构设计"></a>汇聚层网络与接入层网络结构设计</h3><p>网络系统分层设计中层次之间上联带宽与下联带宽的比例一般控制在1:20。</p>]]></content>
    
    
    <categories>
      
      <category>Computer-Certificate-Test</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Computer-Certificate-Test</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>00x2 数组异或操作</title>
    <link href="/2024/07/11/%E7%AE%97%E6%B3%95/00x2%20%E6%95%B0%E7%BB%84%E5%BC%82%E6%88%96%E6%93%8D%E4%BD%9C/"/>
    <url>/2024/07/11/%E7%AE%97%E6%B3%95/00x2%20%E6%95%B0%E7%BB%84%E5%BC%82%E6%88%96%E6%93%8D%E4%BD%9C/</url>
    
    <content type="html"><![CDATA[<h1 id="1486-数组异或操作"><a href="#1486-数组异或操作" class="headerlink" title="1486.数组异或操作"></a><a href="https://leetcode.cn/problems/xor-operation-in-an-array/">1486.数组异或操作</a></h1><p>给你两个整数，<code>n</code> 和 <code>start</code> 。</p><p>数组 <code>nums</code> 定义为：<code>nums[i] = start + 2*i</code>（下标从 0 开始）且 <code>n == nums.length</code> 。</p><p>请返回 <code>nums</code> 中所有元素按位异或（<strong>XOR</strong>）后得到的结果。</p><p><strong>示例 1：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：n = 5, start = 0<br>输出：8<br>解释：数组 nums 为 [0, 2, 4, 6, 8]，其中 (0 ^<span class="hljs-number"> 2 </span>^<span class="hljs-number"> 4 </span>^<span class="hljs-number"> 6 </span>^ 8) =<span class="hljs-number"> 8 </span>。<br>     &quot;^&quot; 为按位异或 XOR 运算符。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：n = 4, start = 3<br>输出：8<br>解释：数组 nums 为 [3, 5, 7, 9]，其中 (3 ^<span class="hljs-number"> 5 </span>^<span class="hljs-number"> 7 </span>^ 9) = 8.<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">输入：n = <span class="hljs-number">1</span>, <span class="hljs-literal">start</span> = <span class="hljs-number">7</span><br>输出：<span class="hljs-number">7</span><br></code></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">输入：n = <span class="hljs-number">10</span>, <span class="hljs-literal">start</span> = <span class="hljs-number">5</span><br>输出：<span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= n &lt;= 1000</code></li><li><code>0 &lt;= start &lt;= 1000</code></li><li><code>n == nums.length</code></li></ul><blockquote><p>[!TIP]</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">xorOperation</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> start)</span> &#123;<br>    <span class="hljs-type">int</span> nums[n];<br>    <span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (i=<span class="hljs-number">0</span>;i&lt;n;i++)<br>    &#123;<br>        nums[i] = start + <span class="hljs-number">2</span>*i;<br>    &#125;<br>    <span class="hljs-type">int</span> result=nums[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">for</span> (i=<span class="hljs-number">1</span>;i&lt;n;i++)<br>    &#123;<br>        result^=nums[i];<br>    &#125;<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure></blockquote>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Algorithm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>00x1 网络系统结构与设计的基本原则</title>
    <link href="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%89%E7%BA%A7%E7%BD%91%E7%BB%9C%E6%8A%80%E6%9C%AF/00x1%20%E7%BD%91%E7%BB%9C%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84%E4%B8%8E%E8%AE%BE%E8%AE%A1%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E5%88%99/"/>
    <url>/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%89%E7%BA%A7%E7%BD%91%E7%BB%9C%E6%8A%80%E6%9C%AF/00x1%20%E7%BD%91%E7%BB%9C%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84%E4%B8%8E%E8%AE%BE%E8%AE%A1%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E5%88%99/</url>
    
    <content type="html"><![CDATA[<h3 id="网络接入技术大体可以分为"><a href="#网络接入技术大体可以分为" class="headerlink" title="网络接入技术大体可以分为"></a>网络接入技术大体可以分为</h3><ol><li><h4 id="数字用户线（xDSL）接入"><a href="#数字用户线（xDSL）接入" class="headerlink" title="数字用户线（xDSL）接入"></a>数字用户线（xDSL）接入</h4><p>xDSL是利用现有的电话网络实现网络接入，能够同时提供电话和网络接入服务。其中HDSL是对称（上行下行带宽一致）的，其他均为非对称（上行下行带宽不一致），且各技术的带宽是经常考察的内容。</p><p>ADSL–非对称（上行下行带宽不一致）数字用户线，利用电话线实现网络接入，能够同时提供电话和网络服务（即上网时电话并不占线，早期的拨号上网业务是上网时电话占线），上行速率在64Kbps-640Kbps之间，下行速率在500Kbps-7Mbps之间，用户可以根据需要选择上行下行速率。</p></li><li><h4 id="光纤同轴电缆混合网（HFC）接入"><a href="#光纤同轴电缆混合网（HFC）接入" class="headerlink" title="光纤同轴电缆混合网（HFC）接入"></a>光纤同轴电缆混合网（HFC）接入</h4><p>HFC是利用现有的有线电视网络实现网络接入，常考的内容包括其带宽、使用光纤和同轴电缆、使用Cable Modem、双向传输（双向，分为上行和下行两个信道）等。</p></li><li><h4 id="光纤接入"><a href="#光纤接入" class="headerlink" title="光纤接入"></a>光纤接入</h4><p>光纤接入技术常考的内容包括带宽最大10Gbps、中继距离最大100km、以OC-3为基准计算带宽或者计算OC-12的带宽。另外无源光纤网PON与ATM结合生成APON（光纤接入），与以太网相结合生成EPON，并且EPON经常会到其他题目中扰乱视线。</p><h5 id="带宽与基准之间的计算方法"><a href="#带宽与基准之间的计算方法" class="headerlink" title="带宽与基准之间的计算方法"></a>带宽与基准之间的计算方法</h5><p>只需要记忆OC-3的带宽即可。OC-3的带宽是155.520Mbps，至于OC-12的带宽，因为（OC）12÷（OC）3&#x3D;4，所以OC-12的带宽是OC-3的带宽的4倍，即155.520*4&#x3D;622.080Mbps。</p></li><li><h4 id="宽带无线接入"><a href="#宽带无线接入" class="headerlink" title="宽带无线接入"></a>宽带无线接入</h4><p>宽带无线接入技术主要包含WLAN、WMAN、Ad hoc（延伸出WSN和WMN）。包含802.11和802.16两个标准，而802.15说的是蓝牙标准。</p></li></ol><h3 id="城域网"><a href="#城域网" class="headerlink" title="城域网"></a>城域网</h3><h4 id="构建宽带城域网的基本技术与方案"><a href="#构建宽带城域网的基本技术与方案" class="headerlink" title="构建宽带城域网的基本技术与方案"></a>构建宽带城域网的基本技术与方案</h4><p>RPR采用双环结构，即两个同心圆的环形<strong>拓扑结构</strong>，<strong>顺时针传输的是外环</strong>，逆时针传输的是内环，能够实现”自愈”功能。RPR的相邻节点最大距离（单根裸光纤最大长度）100km。外环和内环的功能是完全一样的，平时主环工作，副环待命，一旦主环故障，副环将在<strong>50ms</strong>内隔离故障节点和光纤段，接替主环进行工作。RPR带宽利用率高（源节点发出的信息由目的节点收回），环中<strong>每个节点都执行SRP公平算法</strong>，故障出现后能在50ms恢复工作，并且<strong>提供QoS</strong>。</p><p>光以太网是利用光纤的带宽优势，结合以太网成熟的技术，为新一代的宽带城域网提供技术支持。常见的光以太网有10Gbps以太网（10GE）以及RPR（弹性分组环）。<br>    光以太网需要具备以下特征：<br>    1、能够根据用户的需求分配带宽<br>    2、具有认证和授权功能<br>    3、提供计费功能<br>    4、支持VPN和防火墙，保证网络安全<br>    5、支持MPLS，提供QoS服务<br>    6、能够方便快速灵活的适应用户和业务的拓展。<br>    由于光以太网是负责城域网的，这样大规模的网络，可靠性必须符合99.999%的标准。</p><h4 id="宽带城域网的结构"><a href="#宽带城域网的结构" class="headerlink" title="宽带城域网的结构"></a>宽带城域网的结构</h4><p>核心交换层简称核心层，边缘汇聚层简称汇聚层，用户接入层简称接入层。</p><ol><li><strong>核心层承担高速数据交换的功能</strong>，提供高速分组转发、提供QoS（服务质量）（D对）保障、提供至Internet的路由服务，负责汇集各个汇聚层的数据连接至主干网络（A对）。</li><li><strong>汇聚层承担路由与流量汇聚功能</strong>，负责数据的分组、汇聚、转发，并对本地流量进行路由、过滤、流量均衡（C错）、QoS优先级管理、IP地址转换等功能。</li><li><strong>接入层负责用户接入及本地流量控制</strong>，解决“最后一公里”的问题。</li></ol><p></p><p>直白点说，核心层负责数据流量的城际到Internet的相关功能（B对），接入层负责用户的接入（网络入户），汇聚层负责本地流量控制相关业务，以及数据从接入层到核心层的上传下达业务，且仅有相邻层次才可能发生数据的交互工作，不可能跨层次通信（此处有C选项更大的错误–汇接接入层的用户流量，核心层与接入层之间隔着汇聚层，不允许跨层通信。）。</p><h4 id="宽带城域网的特征"><a href="#宽带城域网的特征" class="headerlink" title="宽带城域网的特征"></a>宽带城域网的特征</h4><ol><li>由于是城域网，覆盖范围为一个城域，传输距离较远，传输介质中能满足长距离传输的只有光纤。</li><li>SDN是软件定义网络，并不是路由协议。</li><li>现今的无线网络接入技术已成为主流，融合无线城域网是必然的。</li><li>城域网是以宽带光传输网络为开放平台，以TCP&#x2F;IP协议为基础，通过网络互联设备，实现语音、数据、图像、多媒体视频、IP电话、IP接入和各种增值服务业务与智能业务，并与广域计算机网络、广播电视网、电话交换网互联互通的本地综合业务网络，满足语音、数据、图像、多媒体的需求。</li></ol><h4 id="宽带城域网网络管理的三种基本方案"><a href="#宽带城域网网络管理的三种基本方案" class="headerlink" title="宽带城域网网络管理的三种基本方案"></a>宽带城域网网络管理的三种基本方案</h4><p>带内网络管理、带外网络管理、同时使用带内和带外网络管理。<br>利用<strong>传统的电信网络</strong>进行的网络管理成为“带内”，利用<strong>IP网络和协议</strong>进行管理的称之为“带外”。<br><strong>带内</strong>网络管理利用<strong>数据通信网DCN或公共交换电话网PSTN拨号</strong>；<strong>带外</strong>网络管理利用<strong>网络管理协议SNMP</strong>。<br>汇聚层及<strong>以上</strong>采取带外管理，汇聚层<strong>以下</strong>采用<strong>带内</strong>管理。</p><h4 id="管理和运营宽带城域网的关键技术"><a href="#管理和运营宽带城域网的关键技术" class="headerlink" title="管理和运营宽带城域网的关键技术"></a>管理和运营宽带城域网的关键技术</h4><p>QoS是服务质量，具体表现在延时（从源主机发出数据包开始，数据包送达目的主机，再到源主机接收到目的主机的反馈信息截止的总耗时）、抖动（延时的变化）、吞吐量、包丢失率（丢包率）。保证QoS的技术有资源预留RSVP、区分服务Diffserv、多协议标记交换MPLS。</p><h3 id="广域网"><a href="#广域网" class="headerlink" title="广域网"></a>广域网</h3><h4 id="广域网技术的发展"><a href="#广域网技术的发展" class="headerlink" title="广域网技术的发展"></a>广域网技术的发展</h4><p>光以太网是利用光纤的带宽优势，结合以太网成熟的技术，为新一代的宽带城域网提供技术支持。常见的光以太网有10Gbps以太网（10GE）以及RPR（弹性分组环）。<br>    光以太网需要具备以下特征：<br>    1、能够根据用户的需求分配带宽<br>    2、具有认证和授权功能<br>    3、提供计费功能<br>    4、支持VPN和防火墙，保证网络安全<br>    5、支持MPLS，提供QoS服务<br>    6、能够方便快速灵活的适应用户和业务的拓展。<br>    信元是ATM（异步传输模式）所独有的，只有ATM在使用信元，而信元只用于ATM。</p><p>QoS表现在延时、抖动、吞吐量和丢包率几个方面，采用的技术有RSVP、DiffServ和MPLS。<br>FDDI是光纤分布式数据接口，使用光纤组成的双环结构，是一种自愈环。</p><h3 id="网络接入技术与方法"><a href="#网络接入技术与方法" class="headerlink" title="网络接入技术与方法"></a>网络接入技术与方法</h3><p>三网融合指的是计算机网络、电信通信网和广播电视网。<br>网络接入技术大体可以分为数字用户线（xDSL）接入、光纤同轴电缆混合网（HFC）接入、光纤接入、宽带无线接入。SDH指同步数字体系，该技术用于构建宽带城域网。<br>其中宽带无线接入技术主要包含WLAN、WMAN、Ad hoc，由Ad hoc延伸出WSN和WMN。<br>Cable Modem利用频分复用的方法将双向信道分为上行和下行信道，如果是对称式传输，上行信道速率一般在200kbps~10Mbps，下行信道速率最高可达36Mbps。</p>]]></content>
    
    
    <categories>
      
      <category>Computer-Certificate-Test</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Computer-Certificate-Test</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>00x1 同构字符串</title>
    <link href="/2024/07/06/%E7%AE%97%E6%B3%95/00x1%20%E5%90%8C%E6%9E%84%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <url>/2024/07/06/%E7%AE%97%E6%B3%95/00x1%20%E5%90%8C%E6%9E%84%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    
    <content type="html"><![CDATA[<h1 id="205-同构字符串"><a href="#205-同构字符串" class="headerlink" title="205. 同构字符串"></a><a href="https://leetcode.cn/problems/isomorphic-strings/">205. 同构字符串</a></h1><p>给定两个字符串 <code>s</code> 和 <code>t</code> ，判断它们是否是同构的。</p><p>如果 <code>s</code> 中的字符可以按某种映射关系替换得到 <code>t</code> ，那么这两个字符串是同构的。</p><p>每个出现的字符都应当映射到另一个字符，同时不改变字符的顺序。不同字符不能映射到同一个字符上，相同字符只能映射到同一个字符上，字符可以映射到自己本身。</p><p><strong>示例 1:</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">s</span> = <span class="hljs-string">&quot;egg&quot;</span>, <span class="hljs-attr">t</span> = <span class="hljs-string">&quot;add&quot;</span><br>输出：<span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">s</span> = <span class="hljs-string">&quot;foo&quot;</span>, <span class="hljs-attr">t</span> = <span class="hljs-string">&quot;bar&quot;</span><br>输出：<span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">s</span> = <span class="hljs-string">&quot;paper&quot;</span>, <span class="hljs-attr">t</span> = <span class="hljs-string">&quot;title&quot;</span><br>输出：<span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 5 * 104</code></li><li><code>t.length == s.length</code></li><li><code>s</code> 和 <code>t</code> 由任意有效的 ASCII 字符组成</li></ul><h2 id="参考答案（哈希表"><a href="#参考答案（哈希表" class="headerlink" title="参考答案（哈希表)"></a>参考答案（哈希表)</h2><p>O*(<em>n</em>)算法，这里直接使用的是Java里面的HashMap进行哈希表映射，但是这算法还不是最优的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isIsomorphic</span><span class="hljs-params">(String s, String t)</span> &#123;<br>        <span class="hljs-comment">// 检查两个字符串的长度是否相同，如果不同则直接返回false</span><br>        <span class="hljs-keyword">if</span> (s.length() != t.length()) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 使用两个Map来分别映射s和t中的字符到它们对应的字符</span><br>        Map&lt;Character, Character&gt; sToT = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        Map&lt;Character, Character&gt; tToS = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; s.length(); i++) &#123;<br>            <span class="hljs-type">char</span> <span class="hljs-variable">c1</span> <span class="hljs-operator">=</span> s.charAt(i);<br>            <span class="hljs-type">char</span> <span class="hljs-variable">c2</span> <span class="hljs-operator">=</span> t.charAt(i);<br><br>            <span class="hljs-comment">// 如果s中的字符c1已经映射到了另一个字符，或者t中的字符c2已经映射到了另一个字符</span><br>            <span class="hljs-keyword">if</span> (sToT.containsKey(c1) &amp;&amp; sToT.get(c1) != c2 || <br>                tToS.containsKey(c2) &amp;&amp; tToS.get(c2) != c1) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br><br>            <span class="hljs-comment">// 建立映射关系</span><br>            sToT.put(c1, c2);<br>            tToS.put(c2, c1);<br>        &#125;<br><br>        <span class="hljs-comment">// 如果所有字符都正确映射，返回true</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>[!WARNING]</p><p>执行耗时：</p></blockquote><p><img src="https://raw.gitmirror.com/lammy2021/imagebed/master/202407060930974.png" alt="Java算法耗时"></p><h2 id="参考答案-哈希关联容器"><a href="#参考答案-哈希关联容器" class="headerlink" title="参考答案(哈希关联容器)"></a>参考答案(哈希关联容器)</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isIsomorphic</span><span class="hljs-params">(string s, string t)</span> </span>&#123;<br>        unordered_map&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; st;<br>        <span class="hljs-type">int</span> n=s.<span class="hljs-built_in">size</span>(),m=t.<span class="hljs-built_in">size</span>(),d=m/n;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            <span class="hljs-type">int</span> a=s[i],b=d&gt;<span class="hljs-number">1</span>?<span class="hljs-built_in">stoi</span>(t.<span class="hljs-built_in">substr</span>(i*d+<span class="hljs-number">2</span>,<span class="hljs-number">3</span>)):t[i];<span class="hljs-comment">//截取unicode码的后三位代替ascii码</span><br>            <span class="hljs-keyword">if</span>(st[a+<span class="hljs-number">128</span>]!=st[b])<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            st[a+<span class="hljs-number">128</span>]=st[b]=i+<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><img src="https://raw.gitmirror.com/lammy2021//imagebed/master//202407060954257.png"></p><p><strong>什么鬼东西这么抽象</strong></p>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Algorithm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机三级网络技术2024年9月考试考纲</title>
    <link href="/2024/07/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%89%E7%BA%A7%E7%BD%91%E7%BB%9C%E6%8A%80%E6%9C%AF/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%89%E7%BA%A7%E7%BD%91%E7%BB%9C%E6%8A%80%E6%9C%AF2024%E5%B9%B49%E6%9C%88%E8%80%83%E8%AF%95%E8%80%83%E7%BA%B2/"/>
    <url>/2024/07/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%89%E7%BA%A7%E7%BD%91%E7%BB%9C%E6%8A%80%E6%9C%AF/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%89%E7%BA%A7%E7%BD%91%E7%BB%9C%E6%8A%80%E6%9C%AF2024%E5%B9%B49%E6%9C%88%E8%80%83%E8%AF%95%E8%80%83%E7%BA%B2/</url>
    
    <content type="html"><![CDATA[<h1 id="基本要求"><a href="#基本要求" class="headerlink" title="基本要求"></a>基本要求</h1><p>１． 了解大型网络系统规划、管理方法；</p><p>２． 具备中小型网络系统规划、设计的基本能力；</p><p>３． 掌握中小型网络系统组建、设备配置调试的基本技术；</p><p>４． 掌握企事业单位中小型网络系统现场维护与管理基本技术；</p><p>５． 了解网络技术的发展。</p><h1 id="考试内容"><a href="#考试内容" class="headerlink" title="考试内容"></a>考试内容</h1><h2 id="一、网络规划与设计"><a href="#一、网络规划与设计" class="headerlink" title="一、网络规划与设计"></a>一、网络规划与设计</h2><p>１．网络需求分析。</p><p>２．网络规划设计。</p><p>３．网络设备及选型。</p><p>４．网络综合布线方案设计。</p><p>５．接入技术方案设计。</p><p>６．IP地址规划与路由设计。</p><p>７．网络系统安全设计。</p><h2 id="二、网络构建"><a href="#二、网络构建" class="headerlink" title="二、网络构建"></a>二、网络构建</h2><h3 id="１．局域网组网技术。"><a href="#１．局域网组网技术。" class="headerlink" title="１．局域网组网技术。"></a>１．局域网组网技术。</h3><p>（１）网线制作方法。</p><p>（２）交换机配置与使用方法。</p><p>（３）交换机端口的基本配置。</p><p>（４）交换机VLAN配置。</p><p>（５）交换机STP配置。</p><h3 id="２．路由器配置与使用。"><a href="#２．路由器配置与使用。" class="headerlink" title="２．路由器配置与使用。"></a>２．路由器配置与使用。</h3><p>（１）路由器基本操作与配置方法。</p><p>（２）路由器接口配置。</p><p>（３）路由器静态路由配置。</p><p>（４）RIP动态路由配置。</p><p>（５）OSPF动态路由配置。</p><h3 id="３．路由器高级功能。"><a href="#３．路由器高级功能。" class="headerlink" title="３．路由器高级功能。"></a>３．路由器高级功能。</h3><p>（１）设置路由器为DHCP服务器。</p><p>（２）访问控制列表的配置。</p><p>（３）配置GRE协议。</p><p>（４）配置IPSec协议。</p><p>（５）配置MPLS协议。</p><h3 id="４．无线网络设备安装与调试。"><a href="#４．无线网络设备安装与调试。" class="headerlink" title="４．无线网络设备安装与调试。"></a>４．无线网络设备安装与调试。</h3><h2 id="三、网络环境与应用系统的安装调试"><a href="#三、网络环境与应用系统的安装调试" class="headerlink" title="三、网络环境与应用系统的安装调试"></a>三、网络环境与应用系统的安装调试</h2><p>１．网络环境配置。</p><p>２．WWW服务器安装调试。</p><p>３．E-Mail服务器安装调试。</p><p>４．FTP服务器安装调试。</p><p>５．DNS服务器安装调试。</p><h2 id="四、网络安全技术与网络管理"><a href="#四、网络安全技术与网络管理" class="headerlink" title="四、网络安全技术与网络管理"></a>四、网络安全技术与网络管理</h2><h3 id="１．网络安全。"><a href="#１．网络安全。" class="headerlink" title="１．网络安全。"></a>１．网络安全。</h3><p>（１）网络防病毒软件与防火墙的安装与使用。</p><p>（２）网站系统管理与维护。</p><p>（３）网络攻击防护与漏洞查找。</p><p>（４）网络数据备份与恢复设备的安装与使用。</p><p>（５）其他网络安全软件的安装与使用。</p><h3 id="２．网络管理。"><a href="#２．网络管理。" class="headerlink" title="２．网络管理。"></a>２．网络管理。</h3><p>（１）管理与维护网络用户账户。</p><p>（２）利用工具软件监控和管理网络系统。</p><p>（３）查找与排除网络设备故障。</p><p>（４）常用网络管理软件的安装与使用。</p><h2 id="五、上机操作"><a href="#五、上机操作" class="headerlink" title="五、上机操作"></a>五、上机操作</h2><h3 id="在仿真网络环境下完成以下考核内容："><a href="#在仿真网络环境下完成以下考核内容：" class="headerlink" title="在仿真网络环境下完成以下考核内容："></a>在仿真网络环境下完成以下考核内容：</h3><p>１．交换机配置与使用。</p><p>２．路由器基本操作与配置方法。</p><p>３．网络环境与应用系统安装调试的基本方法。</p><p>４．网络管理与安全设备、软件安装、调试的基本方法。</p><h1 id="考试方式"><a href="#考试方式" class="headerlink" title="考试方式"></a>考试方式</h1><p>上机考试，考试时长120分钟，总分100分。</p>]]></content>
    
    
    <categories>
      
      <category>Computer-Certificate-Test</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Computer-Certificate-Test</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Chapter 1 基于C语言的C++</title>
    <link href="/2024/07/05/C++/Chapter%202%20%E5%BC%80%E5%A7%8B%E5%AD%A6%E4%B9%A0%20C++/"/>
    <url>/2024/07/05/C++/Chapter%202%20%E5%BC%80%E5%A7%8B%E5%AD%A6%E4%B9%A0%20C++/</url>
    
    <content type="html"><![CDATA[<blockquote><p><strong>前言</strong></p><p>玛卡巴卡，这个C++有很多一部分的内容是基于C语言的，先把C语言炒热先吧，这个也就输入和输出是不太一样的格式，其他的都是很像的写法，看看就明白了，喵~</p></blockquote><h1 id="与C语言相似的点的复习"><a href="#与C语言相似的点的复习" class="headerlink" title="与C语言相似的点的复习"></a>与C语言相似的点的复习</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std; <span class="hljs-comment">//告诉编译器使用 std 命名空间。命名空间是 C++ 中一个相对新的概念。</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> a + b;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    string name;<br>    <span class="hljs-type">int</span> age;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">say</span><span class="hljs-params">()</span> </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;My name is &quot;</span> &lt;&lt; name &lt;&lt; <span class="hljs-string">&quot;, I&#x27;m &quot;</span> &lt;&lt; age &lt;&lt; <span class="hljs-string">&quot; years old.&quot;</span> &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">//1.基本的输入输出</span><br>    <span class="hljs-type">int</span> a2;<br>    cin &gt;&gt; a2; <span class="hljs-comment">//从控制台输入一个整数，并将其赋值给变量 a2。</span><br>    cout &lt;&lt; a2 &lt;&lt; endl; <span class="hljs-comment">//将变量 a2 的值输出到控制台。</span><br><br>    cout &lt;&lt; <span class="hljs-string">&quot;Hello, World!&quot;</span> &lt;&lt; endl;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Hello, World!&quot;</span> &lt;&lt; std::endl;<br>    <br>    <span class="hljs-comment">/* 区别：</span><br><span class="hljs-comment">     * cout &lt;&lt; &quot;Hello, World!&quot; &lt;&lt; endl;：这行代码使用了 using namespace std; 这个声明，所以可以直接使用 std 命名空间中的 cout 和 endl。</span><br><span class="hljs-comment">     * std::cout &lt;&lt; &quot;Hello, World!&quot; &lt;&lt; std::endl;：这行代码没有使用 using namespace std; 这个声明，而是在每次使用 std 命名空间中的元素时都显式地添加了 std:: 前缀。</span><br><span class="hljs-comment">     * 也就是说，如果不使用 using namespace std; 这个声明，那么在使用 cout 和 endl 时就必须在前面加上 std:: 前缀。</span><br><span class="hljs-comment">     */</span><br>    <br>    <span class="hljs-comment">//2.typedef 声明</span><br>    <span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> zhengxing; <span class="hljs-comment">//typedef 关键字，用于为数据类型取一个新的名字。</span><br>    zhengxing a = <span class="hljs-number">10</span>;<br>    cout &lt;&lt; a &lt;&lt; endl;<br><br>    <span class="hljs-comment">/* 此处的输出应该是 10，因为 zhengxing 是 int 的别名，所以 zhengxing a = 10; 就相当于 int a = 10;。</span><br><span class="hljs-comment">     * typedef 语句的一般形式是：typedef type newname;，其中 type 是现有的数据类型，newname 是新的数据类型名。</span><br><span class="hljs-comment">     */</span><br><br><br>    <span class="hljs-comment">//3.枚举类型</span><br>    <span class="hljs-keyword">enum</span> <span class="hljs-title class_">color</span> &#123; red, green, blue &#125; c;<br>    c = blue;<br>    cout &lt;&lt; c &lt;&lt; endl;<br><br>    <span class="hljs-comment">/* 此处的输出应该是 2，因为枚举类型的值是从 0 开始的，所以 red 是 0，green 是 1，blue 是 2。</span><br><span class="hljs-comment">     * 枚举类型是一种用户自定义的数据类型，用于定义变量，以表示程序中只能赋予某些离散整数值的变量。</span><br><span class="hljs-comment">     * 枚举类型的一般形式是：enum enum-name &#123; list of names &#125; var-list;，其中 enum-name 是枚举类型的名称，list of names 是枚举类型的值，var-list 是一个或多个枚举变量。</span><br><span class="hljs-comment">     */</span><br><br>    <span class="hljs-comment">//4.类型转换</span><br>    <span class="hljs-type">int</span> i = <span class="hljs-number">10</span>;<br>    <span class="hljs-type">double</span> d = <span class="hljs-number">3.14</span>;<br>    cout &lt;&lt; (<span class="hljs-type">double</span>)i &lt;&lt; endl;<br>    cout &lt;&lt; (<span class="hljs-type">int</span>)d &lt;&lt; endl;<br><br>    <span class="hljs-comment">/* 此处的输出应该是 10 和 3，因为 (double)i 将整数 i 转换为浮点数，(int)d 将浮点数 d 转换为整数。</span><br><span class="hljs-comment">     * 类型转换是将一个数据类型的值转换为另一个数据类型的值，C++ 中有四种类型转换方式：</span><br><span class="hljs-comment">     * 1. static_cast&lt;type&gt;(expression)：用于基本数据类型之间的转换，如 int 转 double，double 转 int。</span><br><span class="hljs-comment">     * 2. dynamic_cast&lt;type&gt;(expression)：用于将基类指针转换为派生类指针。</span><br><span class="hljs-comment">     * 3. const_cast&lt;type&gt;(expression)：用于去除表达式的 const 属性。</span><br><span class="hljs-comment">     * 4. reinterpret_cast&lt;type&gt;(expression)：用于将一个指针转换为另一个类型的指针。</span><br><span class="hljs-comment">     */</span><br><br>    <span class="hljs-comment">//4.1 静态转换</span><br>    <span class="hljs-type">int</span> a1 = <span class="hljs-number">10</span>;<br>    <span class="hljs-type">double</span> b1 = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">double</span>&gt;(a1);<br>    cout &lt;&lt; b1 &lt;&lt; endl;<br><br>    <span class="hljs-comment">//4.2 动态转换</span><br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span> &#123;<br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span> </span>&#123;<br>            cout &lt;&lt; <span class="hljs-string">&quot;Base&quot;</span> &lt;&lt; endl;<br>        &#125;<br><br>    &#125;;<br><br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">Derived</span> : <span class="hljs-keyword">public</span> Base &#123;<br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span> </span>&#123;<br>            cout &lt;&lt; <span class="hljs-string">&quot;Derived&quot;</span> &lt;&lt; endl;<br>        &#125;<br>    &#125;;<br>    Base *b = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Derived</span>();<br>    Derived *d1 = <span class="hljs-built_in">dynamic_cast</span>&lt;Derived *&gt;(b);<br>    d1-&gt;<span class="hljs-built_in">print</span>();<br><br>    <span class="hljs-comment">//4.3 常量转换</span><br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> b2 = <span class="hljs-number">10</span>;<br>    <span class="hljs-type">int</span>&amp; r = <span class="hljs-built_in">const_cast</span>&lt;<span class="hljs-type">int</span>&amp;&gt;(b2); <span class="hljs-comment">// 常量转换，将const int转换为int</span><br>    cout &lt;&lt; r &lt;&lt; endl;<br><br>    <span class="hljs-comment">//4.4 重新解释转换</span><br>    <span class="hljs-type">int</span> a3 = <span class="hljs-number">10</span>;<br>    <span class="hljs-type">int</span> *p = &amp;a3;<br>    <span class="hljs-type">double</span> *dp = <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">double</span> *&gt;(p); <span class="hljs-comment">// 重新解释转换，将int指针转换为double指针</span><br>    cout &lt;&lt; *dp &lt;&lt; endl;<br><br>    <span class="hljs-comment">//5.define</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">define</span> PI 3.14159</span><br>    cout &lt;&lt; PI*<span class="hljs-number">2</span>*<span class="hljs-number">2</span> &lt;&lt; endl;<br><br>    <span class="hljs-comment">//6.const</span><br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> a4 = <span class="hljs-number">10</span>;<br>    <span class="hljs-comment">//a4 = 20; //这里会报错，因为 a4 是一个常量，不能被修改。</span><br>    cout &lt;&lt; a4 &lt;&lt; endl;<br><br>    <span class="hljs-comment">//7.引用</span><br>    <span class="hljs-type">int</span> a5 = <span class="hljs-number">10</span>;<br>    <span class="hljs-type">int</span> &amp;b5 = a5;<br>    b5 = <span class="hljs-number">20</span>;<br>    cout &lt;&lt; a5 &lt;&lt; endl;<br><br>    <span class="hljs-comment">//8.指针</span><br>    <span class="hljs-type">int</span> a6 = <span class="hljs-number">10</span>;<br>    <span class="hljs-type">int</span> *p1 = &amp;a6;<br>    cout &lt;&lt; *p1 &lt;&lt; endl;<br><br>    <span class="hljs-comment">//9.循环</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>        cout &lt;&lt; i &lt;&lt; endl;<br>    &#125;<br><br>    <span class="hljs-comment">//10.判断</span><br>    <span class="hljs-type">int</span> a7 = <span class="hljs-number">10</span>;<br>    <span class="hljs-keyword">if</span> (a7 &gt; <span class="hljs-number">5</span>) &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;a7 &gt; 5&quot;</span> &lt;&lt; endl;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;a7 &lt;= 5&quot;</span> &lt;&lt; endl;<br>    &#125;<br><br>    <span class="hljs-comment">//11.运算符</span><br>    <span class="hljs-type">int</span> a8 = <span class="hljs-number">10</span>;<br>    <span class="hljs-type">int</span> b8 = <span class="hljs-number">20</span>;<br>    cout &lt;&lt; a8 + b8 &lt;&lt; endl;<br>    cout &lt;&lt; a8 - b8 &lt;&lt; endl;<br>    cout &lt;&lt; a8 * b8 &lt;&lt; endl;<br>    cout &lt;&lt; a8 / b8 &lt;&lt; endl;<br>    cout &lt;&lt; a8 % b8 &lt;&lt; endl;<br><br>    <span class="hljs-comment">//12.数组</span><br>    <span class="hljs-type">int</span> arr[<span class="hljs-number">5</span>] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>        cout &lt;&lt; arr[i] &lt;&lt; endl;<br>    &#125;<br><br>    <span class="hljs-comment">//13.函数</span><br>    <span class="hljs-comment">//这里的函数在main外面，这里就在这个main的开头，如果在main的后面，就需要在main的前面声明一下。</span><br>    cout &lt;&lt; <span class="hljs-built_in">add</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>) &lt;&lt; endl;<br><br>    <span class="hljs-comment">//14.结构体</span><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Student</span> &#123;<br>        string name;<br>        <span class="hljs-type">int</span> age;<br>    &#125;;<br>    Student s;<br>    s.name = <span class="hljs-string">&quot;Tom&quot;</span>;<br>    s.age = <span class="hljs-number">18</span>;<br>    cout &lt;&lt; s.name &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; s.age &lt;&lt; endl;<br><br>    <span class="hljs-comment">//15.类</span><br>    <span class="hljs-comment">//这里的类在main外面，这里就在这个main的开头。</span><br>    Person person;<br>    person.name = <span class="hljs-string">&quot;Tom&quot;</span>;<br>    person.age = <span class="hljs-number">18</span>;<br>    person.<span class="hljs-built_in">say</span>();<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<span class="hljs-comment">//终止 main( )函数，并向调用进程返回值 0。</span><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello Hexo!</title>
    <link href="/2024/06/28/hello-world/"/>
    <url>/2024/06/28/hello-world/</url>
    
    <content type="html"><![CDATA[<p>是的，他又换了一个博客的托管的地方，挑来挑去都是回到了Hexo+Github的方式，这样子的话就可以保证我们的博客不会因为虚拟主机或者云服务商的关闭或者服务器故障而丢失，这样子不仅可以保护我们的重要数据，还能确保博客的稳定性。</p><p>虽然很多小伙伴会觉得这样子会导致我们的博客的访问速度降低，因为这个走的是Github Page的网络，确实，这个在国内访问的速度很不咋地，但是我们可以自建CDN进行加速我们的博客对吧，我们可以利用WAF系统来进行中转海外数据进行加速我们的访问速度。</p><p>好像Github Page的CNAME不能用自己的CDN进行加速，这里就只能套CloudFlare的小黄云CDN了，在国内的访问速度还算是可以吧，过得去。比单纯的github.io访问好。</p><p><img src="https://img.lammy.top/file/c98a33d7d2e2faece7f3e.png" alt="img"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Java课堂笔记 第八章 继承、抽象类、接口和枚举</title>
    <link href="/2024/04/23/Java/Java%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0%20%E7%AC%AC%E5%85%AB%E7%AB%A0%20%E7%BB%A7%E6%89%BF%E3%80%81%E6%8A%BD%E8%B1%A1%E7%B1%BB%E3%80%81%E6%8E%A5%E5%8F%A3%E5%92%8C%E6%9E%9A%E4%B8%BE/"/>
    <url>/2024/04/23/Java/Java%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0%20%E7%AC%AC%E5%85%AB%E7%AB%A0%20%E7%BB%A7%E6%89%BF%E3%80%81%E6%8A%BD%E8%B1%A1%E7%B1%BB%E3%80%81%E6%8E%A5%E5%8F%A3%E5%92%8C%E6%9E%9A%E4%B8%BE/</url>
    
    <content type="html"><![CDATA[<h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><h2 id="类的继承"><a href="#类的继承" class="headerlink" title="类的继承"></a>类的继承</h2><p>在Java中，类的继承是一种面向对象编程的重要概念，它允许一个类（称为子类或派生类）基于另一个类（称为父类或基类）来创建。继承允许子类继承父类的属性和方法，并且可以在此基础上添加新的属性和方法，或者修改现有的行为。</p><p>在Java中，继承使用关键字<code>extends</code>来实现。例如，如果有一个<code>Vehicle</code>类作为父类，可以创建一个<code>Car</code>类作为子类，<code>Car</code>类可以继承<code>Vehicle</code>类的属性和方法。示例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 父类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Vehicle</span> &#123;<br>    String brand;<br>    <span class="hljs-type">int</span> year;<br><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">drive</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;The vehicle is moving.&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 子类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Car</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Vehicle</span> &#123;<br>    <span class="hljs-type">int</span> numOfSeats;<br><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">honk</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Beep beep!&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个示例中，<code>Car</code>类继承了<code>Vehicle</code>类的<code>brand</code>和<code>year</code>属性，以及<code>drive()</code>方法。同时，<code>Car</code>类还有自己的属性<code>numOfSeats</code>和方法<code>honk()</code>。</p><p>继承的意义在于：</p><ol><li><strong>代码重用：</strong> 可以通过继承从现有的类中获取属性和方法，避免重复编写相同的代码，提高了代码的可维护性和可读性。</li><li><strong>扩展性：</strong> 可以通过在子类中添加新的属性和方法来扩展父类的功能，从而使得代码更加灵活和可扩展。</li><li><strong>多态性：</strong> 继承是实现多态性的基础之一。子类可以被当做父类的类型来对待，从而实现了代码的通用性和灵活性。</li></ol><h2 id="在子类中访问父类成员"><a href="#在子类中访问父类成员" class="headerlink" title="在子类中访问父类成员"></a>在子类中访问父类成员</h2><p>在Java中，子类可以通过继承来访问父类的成员。这包括父类的字段（属性）和方法。下面是一些关键点：</p><ol><li><strong>继承关系</strong>: 子类继承了父类的成员，这意味着子类可以访问父类中声明为公共（public）或受保护（protected）的字段和方法。</li><li><strong>super关键字</strong>: 子类可以使用<code>super</code>关键字来引用父类的成员。通过<code>super</code>关键字，子类可以调用父类的构造函数、访问父类的方法和字段。</li><li><strong>访问修饰符</strong>: 子类只能访问父类中被声明为公共（public）或受保护（protected）的成员。私有（private）的成员只能在父类内部访问，子类无法直接访问。</li><li><strong>方法重写</strong>: 如果子类中定义了一个与父类中具有相同名称和参数列表的方法，那么子类的方法会覆盖父类的方法。然而，通过<code>super</code>关键字，子类可以调用父类的被覆盖方法。</li><li><strong>字段隐藏</strong>: 如果子类中定义了与父类相同名称的字段，子类的字段会隐藏父类的字段。但通过<code>super</code>关键字，子类可以访问父类的字段。</li></ol><p>示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Parent</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">String</span> <span class="hljs-variable">parentField</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Parent Field&quot;</span>;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">parentMethod</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Parent Method&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Child</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Parent</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">String</span> <span class="hljs-variable">childField</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Child Field&quot;</span>;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">childMethod</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Child Method&quot;</span>);<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">accessParentMembers</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-built_in">super</span>.parentField); <span class="hljs-comment">// 访问父类字段</span><br>        <span class="hljs-built_in">super</span>.parentMethod(); <span class="hljs-comment">// 调用父类方法</span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Child</span> <span class="hljs-variable">child</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Child</span>();<br>        child.accessParentMembers();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个例子中，子类<code>Child</code>继承了父类<code>Parent</code>的成员，并且在<code>accessParentMembers()</code>方法中通过<code>super</code>关键字访问了父类的字段和方法。</p><h2 id="覆盖"><a href="#覆盖" class="headerlink" title="覆盖"></a>覆盖</h2><p>在Java中，覆盖（override）是指子类重新定义父类中已经存在的方法，以改变或扩展其行为。当子类中定义了一个与父类中同名、参数列表相同的方法时，子类的方法将覆盖父类的方法，使得在调用该方法时执行子类中的实现。</p><p>例如，假设有一个父类Animal，其中有一个方法eat():</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">eat</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Animal is eating&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>现在，我们有一个子类Dog，它继承自Animal，并且想要重新定义eat()方法来适应狗的行为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Animal</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">eat</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Dog is eating&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个例子中，Dog类覆盖了父类Animal中的eat()方法。当我们创建一个Dog对象并调用eat()方法时：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Dog</span> <span class="hljs-variable">dog</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Dog</span>();<br>        dog.eat();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出将是：</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">Dog <span class="hljs-keyword">is</span> eating<br></code></pre></td></tr></table></figure><p>这表明调用的是子类Dog中覆盖后的eat()方法，而不是父类Animal中原始的eat()方法。这样，子类就可以根据自己的需要来重新定义父类中已有的方法，实现更加灵活和符合子类特性的行为。</p><h2 id="在父类中访问子类成员"><a href="#在父类中访问子类成员" class="headerlink" title="在父类中访问子类成员"></a>在父类中访问子类成员</h2><p>在Java中，父类无法直接访问子类的成员，因为父类并不知道子类的具体实现细节。然而，可以通过一些机制来实现这种访问，其中一种常见的方法是使用<code>protected</code>关键字。</p><p>假设我们有一个父类<code>Animal</code>和一个子类<code>Dog</code>。如果我们希望父类<code>Animal</code>能够访问子类<code>Dog</code>的成员，我们可以在<code>Dog</code>类中将这些成员声明为<code>protected</code>。</p><p>让我们来看一个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Animal.java</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span> &#123;<br>    <span class="hljs-keyword">protected</span> String name;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Animal</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">introduce</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;I am an animal named &quot;</span> + name);<br>    &#125;<br><br>    <span class="hljs-comment">// 父类访问子类成员的方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">introduceDog</span><span class="hljs-params">(Dog dog)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;This animal&#x27;s subclass is a dog named &quot;</span> + dog.dogName);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// Dog.java</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Animal</span> &#123;<br>    <span class="hljs-keyword">protected</span> String dogName;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Dog</span><span class="hljs-params">(String animalName, String dogName)</span> &#123;<br>        <span class="hljs-built_in">super</span>(animalName);<br>        <span class="hljs-built_in">this</span>.dogName = dogName;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">bark</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Woof! Woof!&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// Main.java</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Dog</span> <span class="hljs-variable">myDog</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Dog</span>(<span class="hljs-string">&quot;Buddy&quot;</span>, <span class="hljs-string">&quot;Rex&quot;</span>);<br>        myDog.introduce(); <span class="hljs-comment">// 输出：I am an animal named Buddy</span><br>        myDog.bark(); <span class="hljs-comment">// 输出：Woof! Woof!</span><br><br>        <span class="hljs-type">Animal</span> <span class="hljs-variable">animal</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Animal</span>(<span class="hljs-string">&quot;Max&quot;</span>);<br>        animal.introduce(); <span class="hljs-comment">// 输出：I am an animal named Max</span><br>        animal.introduceDog(myDog); <span class="hljs-comment">// 输出：This animal&#x27;s subclass is a dog named Rex</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个例子中，<code>Animal</code>类中有一个<code>introduceDog()</code>方法，它接受一个<code>Dog</code>对象作为参数，并能够访问<code>Dog</code>类的<code>dogName</code>属性。虽然<code>Animal</code>类本身并不知道具体的<code>Dog</code>类的实现细节，但是通过将<code>dogName</code>属性声明为<code>protected</code>，使得<code>Animal</code>类可以在其方法中访问这个属性。</p><h2 id="final成员与final类"><a href="#final成员与final类" class="headerlink" title="final成员与final类"></a>final成员与final类</h2><p>在Java中，<code>final</code> 关键字可以用于变量、方法和类，其含义略有不同。</p><ol><li><strong>Final 变量</strong>：<ul><li>当一个变量被声明为 <code>final</code> 时，表示该变量的值不能被修改。一旦被赋值，其数值将永远不会改变。</li><li><code>final</code> 变量通常在声明时就被初始化，而且一般要求在构造函数或实例初始化块中初始化。如果没有在声明时初始化，就必须确保在使用之前进行初始化。</li><li>常见的用途是将一个变量作为常量，例如 <code>final int MAX_SIZE = 100;</code>。</li></ul></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FinalVariableExample</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">MAX_SIZE</span> <span class="hljs-operator">=</span> <span class="hljs-number">100</span>;<br>        <span class="hljs-comment">// 尝试修改 final 变量会导致编译错误</span><br>        <span class="hljs-comment">// MAX_SIZE = 200;</span><br>        System.out.println(<span class="hljs-string">&quot;MAX_SIZE: &quot;</span> + MAX_SIZE);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol><li><strong>Final 方法</strong>：<ul><li>当一个方法被声明为 <code>final</code> 时，表示该方法不能被子类重写。</li><li>这种情况通常用于确保方法的行为不会被子类修改，或者用于提高性能（某些情况下，编译器可以对 <code>final</code> 方法进行优化）。</li></ul></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FinalMethodExample</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printMessage</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;This is a final method.&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SubClass</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">FinalMethodExample</span> &#123;<br>    <span class="hljs-comment">// 无法重写 final 方法，下面的代码会导致编译错误</span><br>    <span class="hljs-comment">// @Override</span><br>    <span class="hljs-comment">// public void printMessage() &#123;</span><br>    <span class="hljs-comment">//     System.out.println(&quot;Trying to override final method.&quot;);</span><br>    <span class="hljs-comment">// &#125;</span><br>&#125;<br></code></pre></td></tr></table></figure><ol><li><strong>Final 类</strong>：<ul><li>当一个类被声明为 <code>final</code> 时，表示该类不能被继承，即不能有子类。</li><li>这种情况通常用于确保类的不可变性或安全性，或者用于提高性能。</li></ul></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FinalClass</span> &#123;<br>    <span class="hljs-comment">// Some code here...</span><br>&#125;<br><br><span class="hljs-comment">// 下面的代码会导致编译错误，因为无法继承 final 类</span><br><span class="hljs-comment">// class SubClass extends FinalClass &#123;</span><br><span class="hljs-comment">//     // Some code here...</span><br><span class="hljs-comment">// &#125;</span><br></code></pre></td></tr></table></figure><p>总的来说，<code>final</code> 关键字在Java中用于声明不可变的实体，包括变量、方法和类。通过使用 <code>final</code>，可以确保代码的稳定性和安全性。</p><h2 id="Object类"><a href="#Object类" class="headerlink" title="Object类"></a>Object类</h2><p>在Java中，Object类是所有类的根类。这意味着每个Java类都直接或间接地继承自Object类。Object类中包含了一些通用的方法，可以被所有其他类所使用。下面是Object类的一些主要方法：</p><ol><li><code>toString()</code>: 返回对象的字符串表示。默认情况下，它返回一个由类名和对象的哈希码组成的字符串。这个方法通常会被子类重写，以便返回更有意义的字符串表示。</li><li><code>equals(Object obj)</code>: 用于比较两个对象是否相等。默认情况下，它使用的是对象的引用比较，即判断两个对象是否指向同一内存地址。通常，需要在子类中重写这个方法，以便根据对象的内容来判断是否相等。</li><li><code>hashCode()</code>: 返回对象的哈希码值。哈希码是根据对象的内部状态计算出来的一个整数值，通常用于在哈希表等数据结构中确定对象的存储位置。</li><li><code>getClass()</code>: 返回对象的运行时类。这个方法返回一个Class对象，该对象包含了类的一些元信息，比如类的名称、方法、字段等。</li><li><code>clone()</code>: 用于创建并返回一个对象的副本。默认情况下，它执行的是浅拷贝，即只复制对象本身而不复制其内部的引用对象。需要注意的是，为了使用clone()方法，类必须实现Cloneable接口，并且重写clone()方法。</li><li><code>finalize()</code>: 这是一个由垃圾回收器在销毁对象之前调用的方法。子类可以重写这个方法，以释放资源或执行其他清理操作。</li></ol><p>下面是一个简单的示例，演示了如何使用Object类的一些方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ObjectExample</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> id;<br>    <span class="hljs-keyword">private</span> String name;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ObjectExample</span><span class="hljs-params">(<span class="hljs-type">int</span> id, String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.id = id;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;ObjectExample&#123;id=&quot;</span> + id + <span class="hljs-string">&quot;, name=&#x27;&quot;</span> + name + <span class="hljs-string">&quot;&#x27;&#125;&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">equals</span><span class="hljs-params">(Object obj)</span> &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span> == obj) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">if</span> (obj == <span class="hljs-literal">null</span> || getClass() != obj.getClass()) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-type">ObjectExample</span> <span class="hljs-variable">that</span> <span class="hljs-operator">=</span> (ObjectExample) obj;<br>        <span class="hljs-keyword">return</span> id == that.id &amp;&amp; Objects.equals(name, that.name);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hashCode</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> Objects.hash(id, name);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">ObjectExample</span> <span class="hljs-variable">obj1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectExample</span>(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;Object 1&quot;</span>);<br>        <span class="hljs-type">ObjectExample</span> <span class="hljs-variable">obj2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectExample</span>(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;Object 2&quot;</span>);<br><br>        <span class="hljs-comment">// 使用toString方法</span><br>        System.out.println(<span class="hljs-string">&quot;Object 1: &quot;</span> + obj1.toString());<br><br>        <span class="hljs-comment">// 使用equals方法比较两个对象</span><br>        System.out.println(<span class="hljs-string">&quot;Are objects equal? &quot;</span> + obj1.equals(obj2));<br><br>        <span class="hljs-comment">// 使用hashCode方法获取哈希码值</span><br>        System.out.println(<span class="hljs-string">&quot;Hash code of Object 1: &quot;</span> + obj1.hashCode());<br><br>        <span class="hljs-comment">// 使用getClass方法获取对象的类</span><br>        System.out.println(<span class="hljs-string">&quot;Class of Object 1: &quot;</span> + obj1.getClass().getName());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个例子创建了一个名为<code>ObjectExample</code>的类，其中重写了<code>toString()</code>、<code>equals()</code>、<code>hashCode()</code>和<code>getClass()</code>方法。在<code>main()</code>方法中，创建了两个<code>ObjectExample</code>对象，并演示了如何使用Object类的这些方法。</p><h2 id="局部变量类型推断与继承"><a href="#局部变量类型推断与继承" class="headerlink" title="局部变量类型推断与继承"></a>局部变量类型推断与继承</h2><p>Java中的局部变量类型推断是指在声明局部变量时，可以使用var关键字进行类型推断，而无需显式指定变量类型。这个特性可以使代码更简洁，同时保持类型安全。</p><p>在Java中，继承是指一个类（称为子类或派生类）可以从另一个类（称为父类或基类）继承属性和方法。子类可以继承父类的公共和受保护的成员，但不会继承私有成员。</p><p>下面是一个结合了局部变量类型推断和继承的示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 定义一个父类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">eat</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Animal is eating&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 定义一个子类，继承自Animal</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Animal</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">bark</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Dog is barking&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 使用var关键字进行类型推断，声明一个Animal对象</span><br>        <span class="hljs-type">var</span> <span class="hljs-variable">animal</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Animal</span>();<br>        animal.eat(); <span class="hljs-comment">// 输出：Animal is eating</span><br><br>        <span class="hljs-comment">// 使用类型推断声明一个Dog对象</span><br>        <span class="hljs-type">var</span> <span class="hljs-variable">dog</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Dog</span>();<br>        dog.eat(); <span class="hljs-comment">// 输出：Animal is eating，子类继承了父类的方法</span><br>        dog.bark(); <span class="hljs-comment">// 输出：Dog is barking</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个例子中，我们使用var关键字来声明局部变量，编译器根据右侧的表达式推断出变量的类型。在main方法中，我们首先声明了一个类型为Animal的变量animal，接着声明了一个类型为Dog的变量dog。通过继承，Dog类可以访问Animal类中的eat()方法，并且还可以调用自己新增的bark()方法。</p><p>这样，我们既利用了局部变量类型推断简化了代码，又展示了继承的概念在Java中的应用。</p><h1 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h1><h2 id="抽象类与抽象方法"><a href="#抽象类与抽象方法" class="headerlink" title="抽象类与抽象方法"></a>抽象类与抽象方法</h2><p>在Java中，抽象类和抽象方法是面向对象编程中的重要概念，用于实现抽象和多态性。</p><ol><li><strong>抽象类（Abstract Class）</strong>：<ul><li>抽象类是不能被实例化的类，即不能直接创建对象。</li><li>抽象类通常用于定义一种抽象的概念，它可能包含一些具体的方法和一些抽象方法。</li><li>抽象类的关键字是<code>abstract</code>，在类的声明中使用。抽象类可以包含抽象方法和非抽象方法。</li><li>如果一个类包含抽象方法，那么这个类必须声明为抽象类。</li><li>抽象类可以拥有构造方法，但是不能直接使用抽象类进行实例化。</li></ul></li><li><strong>抽象方法（Abstract Method）</strong>：<ul><li>抽象方法是一种没有实现的方法，它只包含方法签名而没有方法体。</li><li>抽象方法必须声明在抽象类中，用于被子类实现。</li><li>抽象方法的目的是让子类来实现具体的功能，从而提供多态性。</li><li>子类必须实现抽象类中的所有抽象方法，除非子类本身也是抽象类。</li></ul></li></ol><p>下面是一个简单的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 定义一个抽象类Animal</span><br><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span> &#123;<br>    <span class="hljs-comment">// 抽象方法，表示动物发出的声音</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">makeSound</span><span class="hljs-params">()</span>;<br><br>    <span class="hljs-comment">// 普通方法，表示动物的共同行为</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sleep</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Animal is sleeping&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// Dog类继承自Animal抽象类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Animal</span> &#123;<br>    <span class="hljs-comment">// 实现抽象方法makeSound</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">makeSound</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Dog barks&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// Cat类继承自Animal抽象类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Cat</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Animal</span> &#123;<br>    <span class="hljs-comment">// 实现抽象方法makeSound</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">makeSound</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Cat meows&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 不能直接实例化抽象类Animal</span><br>        <span class="hljs-comment">// Animal animal = new Animal(); // Error</span><br><br>        <span class="hljs-comment">// 可以通过子类来实例化</span><br>        <span class="hljs-type">Animal</span> <span class="hljs-variable">dog</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Dog</span>();<br>        dog.makeSound(); <span class="hljs-comment">// Output: Dog barks</span><br>        dog.sleep(); <span class="hljs-comment">// Output: Animal is sleeping</span><br><br>        <span class="hljs-type">Animal</span> <span class="hljs-variable">cat</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cat</span>();<br>        cat.makeSound(); <span class="hljs-comment">// Output: Cat meows</span><br>        cat.sleep(); <span class="hljs-comment">// Output: Animal is sleeping</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在上面的例子中，<code>Animal</code>类是一个抽象类，其中定义了一个抽象方法<code>makeSound()</code>和一个普通方法<code>sleep()</code>。<code>Dog</code>和<code>Cat</code>类继承自<code>Animal</code>抽象类，并实现了<code>makeSound()</code>方法。在<code>Main</code>类中，我们通过子类实例化了<code>Dog</code>和<code>Cat</code>对象，并调用了它们的方法。</p><h1 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h1><p>在Java中，接口（Interface）是一种抽象的数据类型，它定义了一组方法的声明，但没有提供这些方法的具体实现。接口可以被类实现，这样实现类就必须提供接口中声明的所有方法的具体实现。</p><p>接口的主要特点包括：</p><ol><li>定义方法签名：接口中只包含方法的声明，没有方法的实现。这些方法通常没有方法体，只有方法名、参数列表和返回类型。</li><li>实现类必须实现接口中的所有方法：任何类要实现某个接口，都必须提供接口中定义的所有方法的具体实现。</li><li>支持多继承：一个类可以实现多个接口，这样它就可以获得多个接口中定义的方法。</li></ol><p>接口通常用于定义类之间的协议或契约，以确保不同类在实现相同功能时具有一致的行为。</p><p>例如，假设我们有一个接口<code>Shape</code>，它定义了计算形状面积的方法<code>calculateArea()</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Shape</span> &#123;<br>    <span class="hljs-type">double</span> <span class="hljs-title function_">calculateArea</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>现在我们可以创建实现了<code>Shape</code>接口的不同形状的类，比如矩形和圆：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Rectangle</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Shape</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">double</span> width;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">double</span> height;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Rectangle</span><span class="hljs-params">(<span class="hljs-type">double</span> width, <span class="hljs-type">double</span> height)</span> &#123;<br>        <span class="hljs-built_in">this</span>.width = width;<br>        <span class="hljs-built_in">this</span>.height = height;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">calculateArea</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> width * height;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Circle</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Shape</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">double</span> radius;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Circle</span><span class="hljs-params">(<span class="hljs-type">double</span> radius)</span> &#123;<br>        <span class="hljs-built_in">this</span>.radius = radius;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">calculateArea</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> Math.PI * radius * radius;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在上面的例子中，<code>Rectangle</code>和<code>Circle</code>类都实现了<code>Shape</code>接口，并提供了<code>calculateArea()</code>方法的具体实现。这样，无论我们使用哪种形状的对象，都可以通过调用<code>calculateArea()</code>方法来获取其面积，而不需要知道具体是哪个类的实例。</p><h2 id="接口的实现与接口的回调"><a href="#接口的实现与接口的回调" class="headerlink" title="接口的实现与接口的回调"></a>接口的实现与接口的回调</h2><p>Java中的接口是一种抽象类型，它定义了一组方法的规范，但并不提供这些方法的具体实现。接口可以被类实现，这意味着类需要提供接口中定义的所有方法的具体实现。而接口的回调是一种设计模式，它允许一个对象将自身的引用传递给其他对象，从而使其他对象能够在特定事件发生时调用该对象的方法。</p><p>例如，假设我们有一个简单的接口<code>Callback</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Callback</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">onComplete</span><span class="hljs-params">(String result)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>接下来，我们创建一个类<code>Task</code>，它执行一些任务并在完成时调用回调方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Task</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">execute</span><span class="hljs-params">(Callback callback)</span> &#123;<br>        <span class="hljs-comment">// 执行一些任务</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Task completed successfully&quot;</span>;<br>        <span class="hljs-comment">// 调用回调方法</span><br>        callback.onComplete(result);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>现在，我们可以创建一个实现了<code>Callback</code>接口的类<code>CallbackImpl</code>，并在其中定义回调方法的具体实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CallbackImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Callback</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onComplete</span><span class="hljs-params">(String result)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Task completed: &quot;</span> + result);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>最后，我们将<code>CallbackImpl</code>对象传递给<code>Task</code>对象，并调用<code>execute</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Task</span> <span class="hljs-variable">task</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Task</span>();<br>        <span class="hljs-type">Callback</span> <span class="hljs-variable">callback</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CallbackImpl</span>();<br>        task.execute(callback);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个例子中，<code>Task</code>类通过接口的回调机制，在任务执行完成时调用了<code>CallbackImpl</code>类的<code>onComplete</code>方法，从而实现了任务执行完成后的自定义逻辑。</p><h2 id="接口的继承"><a href="#接口的继承" class="headerlink" title="接口的继承"></a>接口的继承</h2><p>在Java中，接口（interface）可以被其他接口继承，这种继承称为接口的继承。当一个接口继承另一个接口时，它会获得被继承接口的所有方法签名，但不会实现这些方法。继承的接口可以添加新的方法签名或常量，但不能添加新的字段或改变被继承接口的方法签名。</p><p>下面是一个简单的例子来说明接口的继承：</p><p>假设我们有一个动物接口 <code>Animal</code>，其中定义了动物的基本行为，比如 <code>eat()</code> 和 <code>sleep()</code> 方法。然后我们有一个更具体的接口 <code>FlyingAnimal</code>，它继承了 <code>Animal</code> 接口，并添加了 <code>fly()</code> 方法，用于表示可以飞行的动物。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 定义动物接口</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Animal</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">eat</span><span class="hljs-params">()</span>;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">sleep</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-comment">// 定义飞行动物接口，继承自动物接口</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">FlyingAnimal</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Animal</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">fly</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-comment">// 实现具体的飞行动物类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Bird</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">FlyingAnimal</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">eat</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Bird is eating.&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sleep</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Bird is sleeping.&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">fly</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Bird is flying.&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Bird</span> <span class="hljs-variable">bird</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Bird</span>();<br>        bird.eat();   <span class="hljs-comment">// 输出: Bird is eating.</span><br>        bird.sleep(); <span class="hljs-comment">// 输出: Bird is sleeping.</span><br>        bird.fly();   <span class="hljs-comment">// 输出: Bird is flying.</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个例子中，<code>FlyingAnimal</code> 接口继承了 <code>Animal</code> 接口，因此它拥有 <code>eat()</code> 和 <code>sleep()</code> 方法。<code>Bird</code> 类实现了 <code>FlyingAnimal</code> 接口，因此它需要实现 <code>eat()</code>、<code>sleep()</code> 和 <code>fly()</code> 方法。通过这种方式，我们可以组织和描述不同种类的动物，包括它们的共同行为和特性。</p><h2 id="利用接口实现类的多重继承"><a href="#利用接口实现类的多重继承" class="headerlink" title="利用接口实现类的多重继承"></a>利用接口实现类的多重继承</h2><p>在Java中，类只能单继承，这意味着一个类只能直接继承自一个父类。但是，Java提供了接口(interface)来实现类的多重继承。接口可以看作是一种抽象的类，它只包含了方法的声明，而没有方法的实现。类可以实现多个接口，从而获得多个接口中定义的方法。这种方式称为接口多继承。</p><p>让我们通过一个例子来说明：</p><p>假设我们有两个接口 <code>Flyable</code>（可飞行的）和 <code>Swimmable</code>（可游泳的），以及一个类 <code>Bird</code>（鸟），我们希望鸟既能飞又能游泳。我们可以通过接口来实现这种多重继承。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 定义可飞行接口</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Flyable</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">fly</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-comment">// 定义可游泳接口</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Swimmable</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">swim</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-comment">// 定义鸟类实现了可飞行和可游泳接口</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Bird</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Flyable</span>, Swimmable &#123;<br>    <span class="hljs-comment">// 实现飞行方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">fly</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Bird is flying.&quot;</span>);<br>    &#125;<br>    <br>    <span class="hljs-comment">// 实现游泳方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">swim</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Bird is swimming.&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 测试类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Bird</span> <span class="hljs-variable">bird</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Bird</span>();<br>        bird.fly(); <span class="hljs-comment">// 输出: Bird is flying.</span><br>        bird.swim(); <span class="hljs-comment">// 输出: Bird is swimming.</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个例子中，我们定义了两个接口 <code>Flyable</code> 和 <code>Swimmable</code>，它们分别声明了 <code>fly()</code> 和 <code>swim()</code> 方法。然后，我们创建了一个鸟类 <code>Bird</code>，它实现了这两个接口，并提供了对应的方法实现。最后，在测试类中，我们创建了一个鸟的实例，并调用了它的 <code>fly()</code> 和 <code>swim()</code> 方法，这样就实现了对多个接口的继承。</p><h2 id="接口中的静态方法和默认方法"><a href="#接口中的静态方法和默认方法" class="headerlink" title="接口中的静态方法和默认方法"></a>接口中的静态方法和默认方法</h2><p>在Java中，接口（Interface）是一种抽象的数据类型，它定义了一组抽象方法的集合，但是在Java 8中引入了两种新的方法类型：静态方法（Static Methods）和默认方法（Default Methods）。</p><ol><li><strong>静态方法（Static Methods）</strong>：<ul><li>静态方法是在接口中可以直接调用的方法，不需要实现接口的任何实例。</li><li>静态方法在接口中使用<code>static</code>关键字声明。</li><li>这些方法通常用于提供一些与接口相关的实用函数或工具方法。</li><li>静态方法不可被重写或覆盖。</li></ul></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">MyInterface</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">staticMethod</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;This is a static method inside the interface.&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">MyInterface</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        MyInterface.staticMethod(); <span class="hljs-comment">// 调用静态方法</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol><li><strong>默认方法（Default Methods）</strong>：<ul><li>默认方法是在接口中提供的具有默认实现的方法。</li><li>如果实现了接口的类没有提供默认方法的实现，将会使用接口中定义的默认实现。</li><li>默认方法在接口中使用<code>default</code>关键字声明。</li><li>默认方法可以被实现类重写，以提供特定的实现，但不是强制性的。</li></ul></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">MyInterface</span> &#123;<br>    <span class="hljs-keyword">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">defaultMethod</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;This is a default method inside the interface.&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">MyInterface</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Main</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Main</span>();<br>        obj.defaultMethod(); <span class="hljs-comment">// 调用默认方法</span><br>    &#125;<br><br>    <span class="hljs-comment">// 可选：重写默认方法</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">defaultMethod</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Custom implementation of default method.&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个例子中，我们定义了一个接口<code>MyInterface</code>，其中包含一个静态方法<code>staticMethod()</code>和一个默认方法<code>defaultMethod()</code>。然后我们创建了一个类<code>Main</code>，该类实现了<code>MyInterface</code>接口，并演示了如何调用接口中的静态方法和默认方法。</p><h2 id="解决接口多重继承中名字冲突问题"><a href="#解决接口多重继承中名字冲突问题" class="headerlink" title="解决接口多重继承中名字冲突问题"></a>解决接口多重继承中名字冲突问题</h2><p>在Java中，接口是一种抽象类型，它们可以包含方法的声明但不包含方法的实现。当一个类实现多个接口时，可能会出现方法名字冲突的情况，因为不同的接口可能具有相同名字的方法但有不同的实现。为了解决这种冲突，Java 提供了以下两种方式：</p><ol><li><strong>默认方法（Default Methods）</strong>：默认方法允许在接口中为方法提供默认的实现。如果一个类实现了多个接口，并且这些接口中有相同名字的默认方法，那么实现类可以通过重写该方法来解决冲突。</li><li><strong>抽象方法覆盖（Abstract Method Override）</strong>：如果一个类实现了多个接口，并且这些接口中有相同名字的抽象方法（即未提供默认实现的方法），那么实现类必须提供自己的实现来解决冲突。</li></ol><p>下面是一个示例，说明了如何解决接口多重继承中的名字冲突问题：</p><p>假设我们有两个接口：<code>Walkable</code> 和 <code>Runnable</code>，它们都定义了一个名为 <code>move()</code> 的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Walkable</span> &#123;<br>    <span class="hljs-keyword">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">move</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Walking...&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Runnable</span> &#123;<br>    <span class="hljs-keyword">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">move</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Running...&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>现在，我们创建一个类 <code>Human</code>，它实现了这两个接口，并解决了 <code>move()</code> 方法的冲突：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Human</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Walkable</span>, Runnable &#123;<br>    <span class="hljs-comment">// 实现了冲突的 move() 方法</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">move</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 在这里选择调用 Walkable 接口中的 move() 方法</span><br>        Walkable.<span class="hljs-built_in">super</span>.move(); <span class="hljs-comment">// 或者 Runnable.super.move();</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在 <code>Human</code> 类中，我们通过调用 <code>Walkable.super.move()</code> 或者 <code>Runnable.super.move()</code> 来选择调用哪个接口中的 <code>move()</code> 方法，从而解决了冲突。</p><p>通过这种方式，Java 允许了接口多重继承，并提供了一种机制来处理方法名字冲突的问题。</p><h1 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h1><p>在Java中，枚举（Enumeration）是一种特殊的数据类型，用于定义一组命名的常量。枚举类型在定义时列出所有可能的值，这些值在整个程序中是固定不变的。</p><p>枚举类型的定义通常使用<code>enum</code>关键字。定义枚举类型的语法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">EnumName</span> &#123;<br>    VALUE1,<br>    VALUE2,<br>    <span class="hljs-comment">// 可以有更多的值</span><br>&#125;<br></code></pre></td></tr></table></figure><p>其中，<code>EnumName</code>是枚举类型的名称，<code>VALUE1</code>、<code>VALUE2</code>等是枚举类型的常量，它们用逗号分隔。</p><p>下面是一个简单的例子，说明如何定义和使用枚举类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 定义一个枚举类型Season</span><br><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Season</span> &#123;<br>    SPRING,<br>    SUMMER,<br>    AUTUMN,<br>    WINTER<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 使用枚举类型</span><br>        <span class="hljs-type">Season</span> <span class="hljs-variable">currentSeason</span> <span class="hljs-operator">=</span> Season.SPRING;<br>        <br>        <span class="hljs-comment">// 输出当前季节</span><br>        System.out.println(<span class="hljs-string">&quot;Current season is: &quot;</span> + currentSeason);<br>        <br>        <span class="hljs-comment">// 使用switch语句处理枚举类型</span><br>        <span class="hljs-keyword">switch</span> (currentSeason) &#123;<br>            <span class="hljs-keyword">case</span> SPRING:<br>                System.out.println(<span class="hljs-string">&quot;It&#x27;s spring!&quot;</span>);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> SUMMER:<br>                System.out.println(<span class="hljs-string">&quot;It&#x27;s summer!&quot;</span>);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> AUTUMN:<br>                System.out.println(<span class="hljs-string">&quot;It&#x27;s autumn!&quot;</span>);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> WINTER:<br>                System.out.println(<span class="hljs-string">&quot;It&#x27;s winter!&quot;</span>);<br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个例子中，定义了一个枚举类型<code>Season</code>，它包含了四个常量：<code>SPRING</code>、<code>SUMMER</code>、<code>AUTUMN</code>和<code>WINTER</code>。在<code>main</code>方法中，创建了一个<code>currentSeason</code>变量，并将其赋值为<code>Season.SPRING</code>。然后使用<code>switch</code>语句根据季节输出相应的信息。</p><h2 id="不包含方法的枚举"><a href="#不包含方法的枚举" class="headerlink" title="不包含方法的枚举"></a>不包含方法的枚举</h2><p>在Java中，不包含方法的枚举是指使用枚举类型来表示一组固定的常量值，但不需要额外的方法或行为。这种类型的枚举通常用于表示简单的静态常量集合，例如表示一周中的每一天或表示颜色的集合等。</p><p>下面是一个示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 定义一个表示星期的枚举类型</span><br><span class="hljs-keyword">enum</span> <span class="hljs-title class_">DayOfWeek</span> &#123;<br>    SUNDAY,<br>    MONDAY,<br>    TUESDAY,<br>    WEDNESDAY,<br>    THURSDAY,<br>    FRIDAY,<br>    SATURDAY<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 使用枚举常量</span><br>        <span class="hljs-type">DayOfWeek</span> <span class="hljs-variable">today</span> <span class="hljs-operator">=</span> DayOfWeek.MONDAY;<br>        System.out.println(<span class="hljs-string">&quot;Today is &quot;</span> + today);<br>        <br>        <span class="hljs-comment">// 判断今天是不是周末</span><br>        <span class="hljs-keyword">if</span> (today == DayOfWeek.SATURDAY || today == DayOfWeek.SUNDAY) &#123;<br>            System.out.println(<span class="hljs-string">&quot;It&#x27;s a weekend!&quot;</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;It&#x27;s a weekday.&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个例子中，<code>DayOfWeek</code> 枚举类型表示一周中的每一天，但它不包含任何方法或行为。在 <code>Main</code> 类的 <code>main</code> 方法中，我们创建了一个 <code>DayOfWeek</code> 类型的变量 <code>today</code>，并将其初始化为 <code>MONDAY</code>。然后我们根据 <code>today</code> 的值判断今天是不是周末，并打印相应的消息。</p><p>这种不包含方法的枚举类型简单明了，适用于表示静态常量集合的场景。</p><h2 id="包含属性和方法的枚举"><a href="#包含属性和方法的枚举" class="headerlink" title="包含属性和方法的枚举"></a>包含属性和方法的枚举</h2><p>在Java中，枚举（Enumeration）是一种特殊的数据类型，它允许你定义一组命名的常量。与普通的类不同，枚举类型具有固定的实例数量，并且这些实例在程序运行时是不可变的。枚举可以包含属性和方法，使其更灵活和功能更强大。</p><p>下面是一个简单的例子来解释带有属性和方法的枚举：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 定义一个枚举类型表示不同的汽车品牌</span><br><span class="hljs-keyword">enum</span> <span class="hljs-title class_">CarBrand</span> &#123;<br>    TOYOTA(<span class="hljs-string">&quot;Toyota&quot;</span>, <span class="hljs-number">50000</span>),   <span class="hljs-comment">// 枚举实例 TOYOTA，具有名称和价格属性</span><br>    HONDA(<span class="hljs-string">&quot;Honda&quot;</span>, <span class="hljs-number">55000</span>),     <span class="hljs-comment">// 枚举实例 HONDA，具有名称和价格属性</span><br>    BMW(<span class="hljs-string">&quot;BMW&quot;</span>, <span class="hljs-number">80000</span>);         <span class="hljs-comment">// 枚举实例 BMW，具有名称和价格属性</span><br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String name; <span class="hljs-comment">// 枚举实例的名称属性</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> price;   <span class="hljs-comment">// 枚举实例的价格属性</span><br><br>    <span class="hljs-comment">// 构造方法，用于初始化枚举实例的属性</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">CarBrand</span><span class="hljs-params">(String name, <span class="hljs-type">int</span> price)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>        <span class="hljs-built_in">this</span>.price = price;<br>    &#125;<br><br>    <span class="hljs-comment">// 获取汽车品牌名称的方法</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br><br>    <span class="hljs-comment">// 获取汽车价格的方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getPrice</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> price;<br>    &#125;<br><br>    <span class="hljs-comment">// 自定义方法，用于描述汽车信息</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getDescription</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;This is a &quot;</span> + name + <span class="hljs-string">&quot; car with a price of $&quot;</span> + price;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">EnumExample</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 使用枚举实例</span><br>        <span class="hljs-type">CarBrand</span> <span class="hljs-variable">myCar</span> <span class="hljs-operator">=</span> CarBrand.TOYOTA;<br>        <br>        <span class="hljs-comment">// 访问枚举实例的属性和方法</span><br>        System.out.println(<span class="hljs-string">&quot;Car brand: &quot;</span> + myCar.getName());<br>        System.out.println(<span class="hljs-string">&quot;Car price: $&quot;</span> + myCar.getPrice());<br>        System.out.println(myCar.getDescription());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个例子中，我们定义了一个枚举类型 <code>CarBrand</code>，其中包含三个枚举实例：<code>TOYOTA</code>，<code>HONDA</code> 和 <code>BMW</code>。每个枚举实例都有两个属性：<code>name</code> 和 <code>price</code>，并通过构造方法进行初始化。此外，枚举还包含了两个方法 <code>getName()</code> 和 <code>getPrice()</code>，用于获取汽车品牌的名称和价格。我们还定义了一个自定义方法 <code>getDescription()</code>，用于描述汽车的信息。</p><p>在 <code>main</code> 方法中，我们创建了一个 <code>CarBrand</code> 类型的枚举实例 <code>myCar</code>，并通过调用其属性和方法来访问枚举实例的信息。</p><h1 id="包"><a href="#包" class="headerlink" title="包"></a>包</h1><p>在Java中，包（package）是一种用于组织类和接口的机制。包可以理解为文件夹，用于将相关的类和接口组织在一起，以便更好地管理和组织代码。</p><ol><li><strong>命名空间管理</strong>：包提供了命名空间的管理，避免了类名冲突。每个包都有一个唯一的名称，类的全名是包名加上类名，这样就可以确保类名的唯一性。</li><li><strong>代码组织</strong>：包可以帮助组织代码，将相关的类和接口放在一起。这样做可以提高代码的可读性和可维护性，使代码结构更清晰。</li><li><strong>访问控制</strong>：包还可以用于控制访问权限。Java中的访问修饰符（public、protected、private）可以限制对类、接口、方法和属性的访问范围，而包名也可以作为另一层次的访问控制。</li><li><strong>包路径</strong>：在文件系统中，Java包通常对应着文件夹的层次结构。例如，包com.example可以对应到文件系统中的com&#x2F;example文件夹。这种组织方式使得开发人员可以更容易地找到和管理代码文件。</li></ol><p>在Java代码中，使用关键字<code>package</code>来声明一个包，通常放在源文件的第一行。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.example.myapp;<br></code></pre></td></tr></table></figure><p>这表示该源文件中的类和接口都属于com.example.myapp这个包。要在其他源文件中使用这个包中的类和接口，可以使用<code>import</code>语句将其导入，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> com.example.myapp.MyClass;<br></code></pre></td></tr></table></figure><p>这样就可以在当前的源文件中使用com.example.myapp包中的MyClass类了。</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java课堂笔记 第六章 类与对象</title>
    <link href="/2024/04/16/Java/Java%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0%20%E7%AC%AC%E5%85%AD%E7%AB%A0%20%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1/"/>
    <url>/2024/04/16/Java/Java%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0%20%E7%AC%AC%E5%85%AD%E7%AB%A0%20%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1/</url>
    
    <content type="html"><![CDATA[<h1 id="类"><a href="#类" class="headerlink" title="类"></a>类</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>Java中的类是面向对象编程的基本构建块，它是一种抽象数据类型，用于描述具有相同属性和行为的对象集合。类由字段（属性）和方法（行为）组成，可以用来创建对象（实例化）以及定义对象的行为和状态。通过封装、继承和多态等特性，类提供了一种结构化的方式来组织和管理代码，使得代码更易于理解、扩展和维护。</p><h2 id="定义类"><a href="#定义类" class="headerlink" title="定义类"></a>定义类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Animal</span><span class="hljs-params">(String name, <span class="hljs-type">int</span> age)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>        <span class="hljs-built_in">this</span>.age = age;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">makeSound</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 此处留空，等待具体动物的实现</span><br>    &#125;<br><br>    <span class="hljs-comment">// Getters and setters</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getAge</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> age;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setAge</span><span class="hljs-params">(<span class="hljs-type">int</span> age)</span> &#123;<br>        <span class="hljs-built_in">this</span>.age = age;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个Java示例中，我们定义了一个名为Animal的类。类中有两个私有属性<code>name</code>和<code>age</code>，用于表示动物的名称和年龄。</p><p>构造函数<code>Animal(String name, int age)</code>用于初始化动物对象的名称和年龄。</p><p>方法<code>makeSound()</code>目前为空，它将用于之后根据具体动物来实现发出声音的行为。</p><p>我们还提供了一系列getter和setter方法来访问和修改动物的属性。</p><p>现在，我们可以使用这个类来创建不同的动物对象，比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 创建一个名为&quot;狗狗&quot;，年龄为3岁的动物对象</span><br><span class="hljs-type">Animal</span> <span class="hljs-variable">dog</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Animal</span>(<span class="hljs-string">&quot;狗狗&quot;</span>, <span class="hljs-number">3</span>);<br><br><span class="hljs-comment">// 创建一个名为&quot;猫咪&quot;，年龄为5岁的动物对象</span><br><span class="hljs-type">Animal</span> <span class="hljs-variable">cat</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Animal</span>(<span class="hljs-string">&quot;猫咪&quot;</span>, <span class="hljs-number">5</span>);<br></code></pre></td></tr></table></figure><p>这样，我们就创建了两个动物对象，一个是狗狗，一个是猫咪，它们都有自己的名称和年龄属性。</p><h2 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h2><p>Java中的成员变量是指定义在类中的变量，它们用于描述类的属性或状态。成员变量可以是基本数据类型（如int、double、boolean等），也可以是引用类型（如对象、数组等）。</p><p>Java的成员变量有以下特点：</p><ol><li><p><strong>作用域</strong>：成员变量的作用域是整个类，可以在类的任何方法中使用。这使得成员变量在类中的所有方法中都可以共享和访问。</p></li><li><p><strong>默认值</strong>：如果没有显式地对成员变量进行初始化，Java会为其赋予默认值。例如，int类型的默认值是0，boolean类型的默认值是false，对象引用类型的默认值是null。</p></li><li><p><strong>访问修饰符</strong>：成员变量可以使用不同的访问修饰符来控制其访问权限，包括public、private、protected以及默认（即不指定访问修饰符）。</p></li><li><p><strong>静态变量</strong>：使用static关键字声明的成员变量是静态变量，它们属于类而不是对象。静态变量在类加载时被初始化，并且只有一份副本，所有该类的对象共享同一份静态变量。</p></li><li><p><strong>实例变量</strong>：没有使用static关键字声明的成员变量是实例变量，它们属于类的每个对象，每个对象都有自己的一份实例变量副本。</p></li><li><p><strong>可见性</strong>：私有成员变量只能在声明它们的类内部访问，公有成员变量可以在任何地方访问。</p></li></ol><p>通过声明和使用成员变量，Java类能够描述对象的属性，并且可以在类的各个方法中共享和操作这些属性。</p><p>成员变量是Java类中声明的变量，它们用于描述类的特征或属性。比如，考虑一个简单的Java类 <code>Person</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-comment">// 成员变量</span><br>    String name;<br>    <span class="hljs-type">int</span> age;<br>    <span class="hljs-type">double</span> height;<br>    <br>    <span class="hljs-comment">// 构造方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Person</span><span class="hljs-params">(String name, <span class="hljs-type">int</span> age, <span class="hljs-type">double</span> height)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>        <span class="hljs-built_in">this</span>.age = age;<br>        <span class="hljs-built_in">this</span>.height = height;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">displayInfo</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Name: &quot;</span> + name);<br>        System.out.println(<span class="hljs-string">&quot;Age: &quot;</span> + age);<br>        System.out.println(<span class="hljs-string">&quot;Height: &quot;</span> + height);<br>    &#125;<br>    <br>    <span class="hljs-comment">// 主方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 创建一个Person对象</span><br>        <span class="hljs-type">Person</span> <span class="hljs-variable">person1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;Alice&quot;</span>, <span class="hljs-number">25</span>, <span class="hljs-number">1.75</span>);<br>        <span class="hljs-comment">// 调用方法显示信息</span><br>        person1.displayInfo();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个例子中，<code>Person</code> 类有三个成员变量：<code>name</code>、<code>age</code> 和 <code>height</code>，它们分别表示人的姓名、年龄和身高。在构造方法 <code>Person()</code> 中，这些成员变量被初始化。在 <code>displayInfo()</code> 方法中，我们使用这些成员变量来展示一个人的信息。在 <code>main()</code> 方法中，我们创建了一个 <code>Person</code> 对象，并调用了 <code>displayInfo()</code> 方法来显示这个人的信息。</p><h2 id="成员方法"><a href="#成员方法" class="headerlink" title="成员方法"></a>成员方法</h2><p>在Java中，成员方法是类中定义的函数，用于执行特定的操作或返回特定的数值。这些方法被称为“成员”方法，因为它们属于类的实例，可以通过类的对象来调用。</p><p>以下是关于Java成员方法的一些重要特点：</p><ol><li><strong>定义位置</strong>：成员方法被定义在类的内部。它们在类的大括号 <code>&#123;&#125;</code> 中声明，并且可以包含在类的任何部分中。</li><li><strong>访问修饰符</strong>：成员方法可以使用不同的访问修饰符来控制对它们的访问权限，如<code>public</code>、<code>private</code>、<code>protected</code>和默认访问修饰符（当方法没有显式声明修饰符时使用）。</li><li><strong>方法签名</strong>：方法的签名由方法的名称和参数列表组成。参数列表指定方法接受的输入。如果两个方法具有相同的名称但参数列表不同，那么它们被认为是不同的方法，这称为方法的重载。</li><li><strong>返回类型</strong>：成员方法可以返回一个值，也可以是<code>void</code>，表示它不返回任何值。如果方法返回一个值，那么返回值的类型必须与方法声明中的返回类型匹配。</li><li><strong>方法调用</strong>：要调用一个成员方法，需要使用点符号（<code>.</code>）将方法名连接到对象实例上。例如，如果有一个名为<code>myObject</code>的对象，并且该对象有一个名为<code>myMethod</code>的方法，则可以通过<code>myObject.myMethod()</code>来调用它。</li><li><strong>this关键字</strong>：在成员方法中，<code>this</code>关键字可以用来引用当前对象的引用。这在需要明确指定当前对象时非常有用，特别是在方法参数与对象属性具有相同名称时。</li></ol><p>例如，以下是一个简单的Java类，其中包含一个成员方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> value;<br><br>    <span class="hljs-comment">// 成员方法，用于设置值</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setValue</span><span class="hljs-params">(<span class="hljs-type">int</span> newValue)</span> &#123;<br>        <span class="hljs-built_in">this</span>.value = newValue;<br>    &#125;<br><br>    <span class="hljs-comment">// 成员方法，用于获取值</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getValue</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.value;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个类中，<code>setValue</code>方法用于设置<code>value</code>属性的值，而<code>getValue</code>方法用于获取<code>value</code>属性的值。这两个方法都是成员方法，因为它们属于<code>MyClass</code>类的实例。</p><h2 id="私有成员"><a href="#私有成员" class="headerlink" title="私有成员"></a>私有成员</h2><p>当我们说到私有成员时，我们通常指的是类中被声明为私有的成员变量和方法。这意味着这些成员只能在声明它们的类内部被访问，而无法在外部类或对象中直接访问。这种访问限制有助于维护类的封装性，提高代码的安全性和可维护性。</p><p><strong>私有成员变量示例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-keyword">private</span> String name; <span class="hljs-comment">// 私有成员变量</span><br><br>    <span class="hljs-comment">// 构造方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Person</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-comment">// 公有方法用于设置姓名</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-comment">// 公有方法用于获取姓名</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个例子中，<code>name</code> 被声明为私有成员变量，因此外部类无法直接访问它。但是，我们提供了公有的 <code>setName</code> 和 <code>getName</code> 方法来允许外部类间接地访问和修改 <code>name</code> 的值。</p><p><strong>私有成员方法示例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Calculator</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> &#123; <span class="hljs-comment">// 私有成员方法</span><br>        <span class="hljs-keyword">return</span> a + b;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">performAddition</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> &#123;<br>        <span class="hljs-comment">// 外部类调用私有成员方法</span><br>        <span class="hljs-keyword">return</span> add(x, y);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个例子中，<code>add</code> 方法被声明为私有成员方法，因此无法在外部类中直接调用它。但是，我们在 <code>Calculator</code> 类中提供了 <code>performAddition</code> 方法，通过它来间接地调用 <code>add</code> 方法来执行加法操作。</p><p>这些例子展示了私有成员在Java中的使用，它们帮助我们隐藏类的内部实现细节，只暴露必要的接口给外部使用，从而提高了代码的安全性和可维护性。</p><h2 id="公有成员"><a href="#公有成员" class="headerlink" title="公有成员"></a>公有成员</h2><p>在Java中，公有成员是指被声明为public访问修饰符的类成员，可以被任何其他类访问。这意味着公有成员可以在不同的类中被直接访问和使用，而不需要通过继承或其他方式。公有成员对于构建模块化和可重用的代码非常重要，因为它们允许其他类与其交互而不暴露内部实现细节。</p><p>举个例子，假设我们有一个名为Person的类，其中包含了一个公有成员变量name和一个公有成员方法sayHello()。下面是一个简单的Java代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-keyword">public</span> String name;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Person</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sayHello</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Hello, my name is &quot;</span> + name + <span class="hljs-string">&quot;!&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个例子中，name是一个公有成员变量，它可以被其他类直接访问。同样，sayHello()方法也是一个公有成员方法，其他类可以通过创建Person对象并调用该方法来与Person类交互。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Person</span> <span class="hljs-variable">person1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;Alice&quot;</span>);<br>        <span class="hljs-type">Person</span> <span class="hljs-variable">person2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;Bob&quot;</span>);<br><br>        System.out.println(<span class="hljs-string">&quot;Person 1&#x27;s name: &quot;</span> + person1.name);<br>        person2.sayHello();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个示例中，我们创建了两个Person对象，分别设置了它们的name属性，并通过调用sayHello()方法来展示公有成员方法的使用。</p><h2 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h2><p>在Java中，方法的重载是指在同一个类中可以有多个方法，它们具有相同的名称但参数列表不同的特性。这些不同的参数可以是参数的数量、类型或顺序。</p><p>举个例子，假设有一个类叫做Calculator，它包含了两个名为add的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Calculator</span> &#123;<br>    <span class="hljs-comment">// 第一个add方法，接受两个整数参数</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> &#123;<br>        <span class="hljs-keyword">return</span> a + b;<br>    &#125;<br><br>    <span class="hljs-comment">// 第二个add方法，接受三个整数参数</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> c)</span> &#123;<br>        <span class="hljs-keyword">return</span> a + b + c;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里的两个add方法就展示了方法重载的概念。虽然它们都叫做add，但是它们的参数列表不同。第一个add方法接受两个整数参数，而第二个add方法接受三个整数参数。当你调用add方法时，Java会根据你提供的参数数量和类型来决定调用哪个版本的add方法。</p><p>方法重载使得代码更具灵活性和可读性，因为它允许我们使用相同的方法名来完成不同的操作，只要参数列表不同即可。</p><h1 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h1><h2 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h2><p>在Java中，对象是指程序中的实体，它可以代表现实世界中的任何东西，如人、车、动物等。对象是类的实例化，类是定义对象的模板或蓝图。每个对象都有其自身的属性（也称为状态或字段）和行为（也称为方法或函数）。</p><p>举个例子，假设有一个类叫做”Car”（汽车），它描述了汽车的属性和行为。在程序中创建一个具体的汽车对象时，该对象就具有了Car类定义的属性和行为。汽车对象的属性可能包括颜色、品牌、型号等，而行为则可能包括启动、加速、刹车等操作。</p><p>Java中的对象具有以下特点：</p><ol><li>封装性（Encapsulation）：对象封装了其状态和行为，可以隐藏内部实现细节，只暴露必要的接口给外部使用。</li><li>继承性（Inheritance）：一个类可以从另一个类继承属性和行为，这样可以重用代码并构建层次结构。</li><li>多态性（Polymorphism）：允许使用统一的接口来操作不同类型的对象，提高了灵活性和可扩展性。</li></ol><p>通过使用对象，Java程序可以更好地模拟现实世界中的情景，并实现复杂的功能。</p><h2 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h2><p>当在Java中创建对象时，你通常会使用关键字 <code>new</code> 加上构造函数来实现。构造函数是一个特殊的方法，用于初始化对象的实例变量。这里有一个简单的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Car</span> &#123;<br>    <span class="hljs-comment">// 实例变量</span><br>    String brand;<br>    String model;<br>    <span class="hljs-type">int</span> year;<br><br>    <span class="hljs-comment">// 构造函数</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Car</span><span class="hljs-params">(String brand, String model, <span class="hljs-type">int</span> year)</span> &#123;<br>        <span class="hljs-built_in">this</span>.brand = brand;<br>        <span class="hljs-built_in">this</span>.model = model;<br>        <span class="hljs-built_in">this</span>.year = year;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 使用 new 关键字创建 Car 对象，并传入参数调用构造函数</span><br>        <span class="hljs-type">Car</span> <span class="hljs-variable">myCar</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Car</span>(<span class="hljs-string">&quot;Toyota&quot;</span>, <span class="hljs-string">&quot;Corolla&quot;</span>, <span class="hljs-number">2020</span>);<br><br>        <span class="hljs-comment">// 访问对象的属性并打印输出</span><br>        System.out.println(<span class="hljs-string">&quot;My car is a &quot;</span> + myCar.year + <span class="hljs-string">&quot; &quot;</span> + myCar.brand + <span class="hljs-string">&quot; &quot;</span> + myCar.model + <span class="hljs-string">&quot;.&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个例子中，我们定义了一个 <code>Car</code> 类，其中包含了品牌、型号和生产年份等实例变量。通过定义 <code>public Car(String brand, String model, int year)</code> 构造函数，我们可以在创建对象时传入这些参数，并通过 <code>new Car(&quot;Toyota&quot;, &quot;Corolla&quot;, 2020)</code> 来实例化一个 <code>Car</code> 对象。然后我们可以通过访问对象的属性来获取和操作对象的状态信息。</p><h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><p>构造方法是在创建对象时调用的特殊方法，用于初始化对象的状态。在Java中，构造方法的名称必须与类名相同，但没有返回类型，甚至不返回void。它们通常用于执行对象的初始化任务，例如设置对象的初始状态或分配资源。</p><p>构造方法在以下情况下被调用：</p><ol><li>当使用<code>new</code>关键字创建对象时。</li><li>在创建对象数组时。</li></ol><p>构造方法可以被重载，这意味着同一个类可以有多个构造方法，只要它们的参数列表不同即可。</p><p>这是一个简单的Java类和构造方法的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Car</span> &#123;<br>    <span class="hljs-comment">// 定义类的成员变量</span><br>    String brand;<br>    String color;<br>    <span class="hljs-type">int</span> year;<br><br>    <span class="hljs-comment">// 构造方法，用于初始化Car对象的状态</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Car</span><span class="hljs-params">(String brand, String color, <span class="hljs-type">int</span> year)</span> &#123;<br>        <span class="hljs-built_in">this</span>.brand = brand;<br>        <span class="hljs-built_in">this</span>.color = color;<br>        <span class="hljs-built_in">this</span>.year = year;<br>    &#125;<br><br>    <span class="hljs-comment">// 另一个构造方法，重载了上面的构造方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Car</span><span class="hljs-params">(String brand)</span> &#123;<br>        <span class="hljs-built_in">this</span>.brand = brand;<br>        <span class="hljs-built_in">this</span>.color = <span class="hljs-string">&quot;Unknown&quot;</span>;<br>        <span class="hljs-built_in">this</span>.year = <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 方法用于打印Car对象的信息</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">displayInfo</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Brand: &quot;</span> + brand + <span class="hljs-string">&quot;, Color: &quot;</span> + color + <span class="hljs-string">&quot;, Year: &quot;</span> + year);<br>    &#125;<br><br>    <span class="hljs-comment">// 主方法用于演示如何使用构造方法创建对象</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 使用构造方法创建Car对象</span><br>        <span class="hljs-type">Car</span> <span class="hljs-variable">myCar1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Car</span>(<span class="hljs-string">&quot;Toyota&quot;</span>, <span class="hljs-string">&quot;Red&quot;</span>, <span class="hljs-number">2022</span>);<br>        <span class="hljs-type">Car</span> <span class="hljs-variable">myCar2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Car</span>(<span class="hljs-string">&quot;Honda&quot;</span>);<br><br>        <span class="hljs-comment">// 调用对象的方法显示信息</span><br>        myCar1.displayInfo();<br>        myCar2.displayInfo();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个例子中，我们定义了一个<code>Car</code>类，它有两个构造方法：一个接受品牌、颜色和年份参数，另一个只接受品牌参数。我们在<code>main</code>方法中使用这些构造方法创建了两个<code>Car</code>对象，并调用了<code>displayInfo</code>方法来显示每个对象的信息。</p><h3 id="构造方法的重载"><a href="#构造方法的重载" class="headerlink" title="构造方法的重载"></a>构造方法的重载</h3><p>当你在Java中创建一个类时，你可以定义一个或多个构造方法。构造方法是一种特殊的方法，用于在创建类的新实例时初始化对象。构造方法的重载是指在同一个类中定义多个构造方法，它们具有相同的名称但是参数列表不同。</p><p>让我们以一个简单的例子来说明Java构造方法的重载。假设我们有一个名为<code>Car</code>的类，我们想为其定义不同类型的构造方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Car</span> &#123;<br>    <span class="hljs-keyword">private</span> String brand;<br>    <span class="hljs-keyword">private</span> String model;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> year;<br><br>    <span class="hljs-comment">// 构造方法1：无参构造方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Car</span><span class="hljs-params">()</span> &#123;<br>        brand = <span class="hljs-string">&quot;Unknown&quot;</span>;<br>        model = <span class="hljs-string">&quot;Unknown&quot;</span>;<br>        year = <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 构造方法2：接受品牌参数的构造方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Car</span><span class="hljs-params">(String brand)</span> &#123;<br>        <span class="hljs-built_in">this</span>.brand = brand;<br>        model = <span class="hljs-string">&quot;Unknown&quot;</span>;<br>        year = <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 构造方法3：接受品牌、型号和年份参数的构造方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Car</span><span class="hljs-params">(String brand, String model, <span class="hljs-type">int</span> year)</span> &#123;<br>        <span class="hljs-built_in">this</span>.brand = brand;<br>        <span class="hljs-built_in">this</span>.model = model;<br>        <span class="hljs-built_in">this</span>.year = year;<br>    &#125;<br><br>    <span class="hljs-comment">// 其他类成员和方法...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>在这个示例中，我们定义了三个构造方法，它们实现了构造方法的重载。</p><ol><li>第一个构造方法是无参构造方法，它会将<code>brand</code>、<code>model</code>和<code>year</code>初始化为默认值。</li><li>第二个构造方法接受一个<code>brand</code>参数，并将<code>brand</code>设置为指定值，同时将<code>model</code>和<code>year</code>初始化为默认值。</li><li>第三个构造方法接受<code>brand</code>、<code>model</code>和<code>year</code>三个参数，并分别将它们设置为指定的值。</li></ol><p>通过这种方式，我们可以根据不同的需求来选择使用合适的构造方法来创建<code>Car</code>类的实例。</p><h3 id="公有构造方法以及私有构造方法"><a href="#公有构造方法以及私有构造方法" class="headerlink" title="公有构造方法以及私有构造方法"></a>公有构造方法以及私有构造方法</h3><p>在Java中，构造方法是用来创建对象的特殊类型的方法。公有构造方法（Public Constructor）和私有构造方法（Private Constructor）是两种常见的构造方法类型。</p><ol><li><strong>公有构造方法</strong>：<ul><li>公有构造方法是通过关键字 <code>public</code> 声明的构造方法。</li><li>公有构造方法可以被任何类访问和调用，包括类的外部。</li><li>当我们希望外部代码能够直接创建类的对象时，就会使用公有构造方法。</li><li>公有构造方法通常用于提供对象的初始化功能，并且可以在实例化对象时传入参数来初始化对象的状态。</li></ul></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br>    <span class="hljs-comment">// 公有构造方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyClass</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 构造方法体</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol><li><strong>私有构造方法</strong>：<ul><li>私有构造方法是通过关键字 <code>private</code> 声明的构造方法。</li><li>私有构造方法只能在同一个类中被调用，外部类无法直接访问私有构造方法。</li><li>私有构造方法通常用于控制对象的创建方式，限制外部代码对对象的创建。</li><li>私有构造方法通常与静态工厂方法一起使用，以实现单例模式、工厂模式等设计模式。</li></ul></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br>    <span class="hljs-comment">// 私有构造方法</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">MyClass</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 构造方法体</span><br>    &#125;<br><br>    <span class="hljs-comment">// 静态工厂方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> MyClass <span class="hljs-title function_">createInstance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyClass</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>通过以上例子，你可以看到公有构造方法和私有构造方法的区别，以及它们在Java中的用途。</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java-Debug 读取一行的数据与逐行读取</title>
    <link href="/2024/03/27/Java/Java-Debug%20%E8%AF%BB%E5%8F%96%E4%B8%80%E8%A1%8C%E7%9A%84%E6%95%B0%E6%8D%AE%E4%B8%8E%E9%80%90%E8%A1%8C%E8%AF%BB%E5%8F%96/"/>
    <url>/2024/03/27/Java/Java-Debug%20%E8%AF%BB%E5%8F%96%E4%B8%80%E8%A1%8C%E7%9A%84%E6%95%B0%E6%8D%AE%E4%B8%8E%E9%80%90%E8%A1%8C%E8%AF%BB%E5%8F%96/</url>
    
    <content type="html"><![CDATA[<h1 id="重现代码"><a href="#重现代码" class="headerlink" title="重现代码"></a>重现代码</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-type">BufferedReader</span> <span class="hljs-variable">buf</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InputStreamReader</span>(System.in));<br>        <span class="hljs-type">int</span> year, month, day;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> buf.readLine();<br>        year = Integer.parseInt(str);<br>        str = buf.readLine();<br>        month = Integer.parseInt(str);<br>        str = buf.readLine();<br>        day = Integer.parseInt(str);<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">total</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>        <span class="hljs-type">int</span>[] pinDaysInMonth = &#123;<span class="hljs-number">31</span>, <span class="hljs-number">28</span>, <span class="hljs-number">31</span>, <span class="hljs-number">30</span>, <span class="hljs-number">31</span>, <span class="hljs-number">30</span>, <span class="hljs-number">31</span>, <span class="hljs-number">31</span>, <span class="hljs-number">30</span>, <span class="hljs-number">31</span>, <span class="hljs-number">30</span>, <span class="hljs-number">31</span>&#125;;<br><span class="hljs-type">int</span>[] runDaysInMonth = &#123;<span class="hljs-number">31</span>, <span class="hljs-number">29</span>, <span class="hljs-number">31</span>, <span class="hljs-number">30</span>, <span class="hljs-number">31</span>, <span class="hljs-number">30</span>, <span class="hljs-number">31</span>, <span class="hljs-number">31</span>, <span class="hljs-number">30</span>, <span class="hljs-number">31</span>, <span class="hljs-number">30</span>, <span class="hljs-number">31</span>&#125;;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; month - <span class="hljs-number">1</span>; i++) &#123;<br><span class="hljs-keyword">if</span>(year%<span class="hljs-number">4</span>==<span class="hljs-number">0</span>)&#123;<br>total += runDaysInMonth[i];<br>&#125;<br><span class="hljs-keyword">else</span>&#123;<br>  total +=pinDaysInMonth[i];<br>&#125;<br>        &#125;<br><br>        total += day;<br><br>        System.out.println(<span class="hljs-string">&quot;Total days: &quot;</span> + total);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这段代码的数据读取是逐行读取导致清览题库的检测数据过不了，因为他的检测数据是<code>2021 11 10</code> 这样子的数据，导致输出<code>Exception in thread &quot;main&quot; java.lang.NumberFormatException: For input string: &quot;2021 11 10&quot; at java.base/java.lang.NumberFormatException.forInputString(NumberFormatException.java:65) at java.base/java.lang.Integer.parseInt(Integer.java:652) at java.base/java.lang.Integer.parseInt(Integer.java:770) at Main.main(Main.java:8)</code> </p><h1 id="修改方式"><a href="#修改方式" class="headerlink" title="修改方式"></a>修改方式</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-type">BufferedReader</span> <span class="hljs-variable">buf</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InputStreamReader</span>(System.in));<br>        String[] inputs = buf.readLine().split(<span class="hljs-string">&quot; &quot;</span>);<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">year</span> <span class="hljs-operator">=</span> Integer.parseInt(inputs[<span class="hljs-number">0</span>]);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">month</span> <span class="hljs-operator">=</span> Integer.parseInt(inputs[<span class="hljs-number">1</span>]);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">day</span> <span class="hljs-operator">=</span> Integer.parseInt(inputs[<span class="hljs-number">2</span>]);<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">total</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>        <span class="hljs-type">int</span>[] pinDaysInMonth = &#123;<span class="hljs-number">31</span>, <span class="hljs-number">28</span>, <span class="hljs-number">31</span>, <span class="hljs-number">30</span>, <span class="hljs-number">31</span>, <span class="hljs-number">30</span>, <span class="hljs-number">31</span>, <span class="hljs-number">31</span>, <span class="hljs-number">30</span>, <span class="hljs-number">31</span>, <span class="hljs-number">30</span>, <span class="hljs-number">31</span>&#125;;<br><span class="hljs-type">int</span>[] runDaysInMonth = &#123;<span class="hljs-number">31</span>, <span class="hljs-number">29</span>, <span class="hljs-number">31</span>, <span class="hljs-number">30</span>, <span class="hljs-number">31</span>, <span class="hljs-number">30</span>, <span class="hljs-number">31</span>, <span class="hljs-number">31</span>, <span class="hljs-number">30</span>, <span class="hljs-number">31</span>, <span class="hljs-number">30</span>, <span class="hljs-number">31</span>&#125;;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; month - <span class="hljs-number">1</span>; i++) &#123;<br><span class="hljs-keyword">if</span>(year%<span class="hljs-number">4</span>==<span class="hljs-number">0</span>)&#123;<br>total += runDaysInMonth[i];<br>&#125;<br><span class="hljs-keyword">else</span>&#123;<br>  total +=pinDaysInMonth[i];<br>&#125;<br>        &#125;<br><br>        total += day;<br><br>        System.out.println(<span class="hljs-string">&quot;Total days: &quot;</span> + total);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>Debug</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java课堂笔记 第五章 字符串与正则表达式</title>
    <link href="/2024/03/19/Java/Java%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0%20%E7%AC%AC%E4%BA%94%E7%AB%A0%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%8E%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <url>/2024/03/19/Java/Java%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0%20%E7%AC%AC%E4%BA%94%E7%AB%A0%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%8E%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="String型字符串"><a href="#String型字符串" class="headerlink" title="String型字符串"></a>String型字符串</h1><h2 id="定义方式"><a href="#定义方式" class="headerlink" title="定义方式"></a>定义方式</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//二段式</span><br>String str0;<br>str0 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;Hello, World!&quot;</span>);<br><br><span class="hljs-comment">// 使用字符串字面值定义一个String变量</span><br><span class="hljs-type">String</span> <span class="hljs-variable">str1</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Hello, World!&quot;</span>;<br><br><span class="hljs-comment">// 使用String构造函数定义一个String变量</span><br><span class="hljs-type">String</span> <span class="hljs-variable">str2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;Hello, World!&quot;</span>);<br></code></pre></td></tr></table></figure><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>第二种方法和第三种方法所储存的方式不一样，所以二者即使字符串内容一致，但是使用&#x3D;&#x3D;运算符判断时候还是false结果。</p><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> ch05;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ch055</span> &#123;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><span class="hljs-comment">// TODO Auto-generated method stub</span><br>String s1=<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;aaaa&quot;</span>);<br>String s2=<span class="hljs-string">&quot;aaaa&quot;</span>;<br>String str;<br>str = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;aaaa&quot;</span>);<br>System.out.println(s1==s2);<br>System.out.println(str==s1);<br>String s3=<span class="hljs-string">&quot;aaaa&quot;</span>;<br>System.out.println(s2==s3);<br>String s4=<span class="hljs-string">&quot;aaa&quot;</span>+<span class="hljs-string">&quot;a&quot;</span>;<br>System.out.println(s4==s3);<br>String s5=<span class="hljs-string">&quot;aa&quot;</span>;<br>s5=s5+<span class="hljs-string">&quot;aa&quot;</span>;<br>System.out.println(s4==s5);<br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="String类常用方法"><a href="#String类常用方法" class="headerlink" title="String类常用方法"></a>String类常用方法</h1><h2 id="equals"><a href="#equals" class="headerlink" title="equals"></a>equals</h2><p><code>equals()</code>方法用于比较两个字符串的内容是否相等</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> ch05;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ch055</span> &#123;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><span class="hljs-comment">// TODO Auto-generated method stub</span><br>String s1=<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;aaaa&quot;</span>);<br>String str;<br>str = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;aaaa&quot;</span>);<br><span class="hljs-type">String</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span>(<span class="hljs-string">&quot;aaaa&quot;</span>);<br><span class="hljs-keyword">if</span>(str.equals(s2))&#123;<br>System.out.println(<span class="hljs-string">&quot;YES&quot;</span>);<br>&#125;<br><span class="hljs-keyword">if</span>(str.equals(s1))&#123;<br>System.out.println(<span class="hljs-string">&quot;YES&quot;</span>);<br>&#125;<br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="substring与charAt"><a href="#substring与charAt" class="headerlink" title="substring与charAt"></a>substring与charAt</h2><p>在Java中，<code>substring()</code>和<code>charAt()</code>是用于处理字符串的常用方法，它们有不同的作用：</p><ul><li><code>substring(int beginIndex, int endIndex)</code>: <code>substring()</code>方法用于从原始字符串中提取子串。它接受两个参数，起始索引(<code>beginIndex</code>)和结束索引(<code>endIndex</code>)，返回从<code>beginIndex</code>到<code>endIndex-1</code>之间的子字符串。</li><li><code>charAt(int index)</code>: <code>charAt()</code>方法用于获取字符串中指定位置的字符。它接受一个整数参数<code>index</code>，表示要获取的字符在字符串中的位置，返回该位置上的字符。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> ch05;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ch055</span> &#123;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><span class="hljs-type">String</span> <span class="hljs-variable">number</span> <span class="hljs-operator">=</span><span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span> (<span class="hljs-string">&quot;12345678910&quot;</span>);<br>System.out.println(<span class="hljs-string">&quot;&quot;</span> + number.charAt(<span class="hljs-number">0</span>) + number.charAt(<span class="hljs-number">1</span>) + number.charAt(<span class="hljs-number">2</span>) + <span class="hljs-string">&quot;****&quot;</span> + number.charAt(<span class="hljs-number">7</span>) + number.charAt(<span class="hljs-number">8</span>) + number.charAt(<span class="hljs-number">9</span>) + number.charAt(<span class="hljs-number">10</span>));<br><span class="hljs-comment">//或者</span><br>        System.out.println(number.substring(<span class="hljs-number">0</span>, <span class="hljs-number">3</span>)+<span class="hljs-string">&quot;****&quot;</span>+number.substring(<span class="hljs-number">7</span>, <span class="hljs-number">11</span>));<br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h1><h2 id="判断字符串是否为回文"><a href="#判断字符串是否为回文" class="headerlink" title="判断字符串是否为回文"></a>判断字符串是否为回文</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> ch05;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ch055</span> &#123;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;   <br>        <span class="hljs-type">String</span> <span class="hljs-variable">hui</span> <span class="hljs-operator">=</span><span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;123321&quot;</span>);<br>        String newStr=<span class="hljs-string">&quot;&quot;</span>;<br>        String sub;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;hui.length();i++)<br>        &#123;<br>        sub=hui.substring(i, i+<span class="hljs-number">1</span>);<br>        newStr=sub+newStr;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(hui.equals(newStr)) System.out.println(<span class="hljs-string">&quot;YES&quot;</span>);<br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h1><p>在Java中，正则表达式是用于匹配、搜索和替换文本的强大工具。以下是Java中正则表达式的主要使用方法：</p><h2 id="Pattern-类和-Matcher-类"><a href="#Pattern-类和-Matcher-类" class="headerlink" title="Pattern 类和 Matcher 类"></a><strong>Pattern 类和 Matcher 类</strong></h2><p><code>Pattern</code>类表示编译后的正则表达式模式，<code>Matcher</code>类用于对输入字符串进行匹配操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">text</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Hello, world!&quot;</span>;<br><br><span class="hljs-type">String</span> <span class="hljs-variable">pattern</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;(H\\w+)&quot;</span>; <span class="hljs-comment">// 匹配以H开头的单词</span><br><br><span class="hljs-type">Pattern</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> Pattern.compile(pattern);<br><br><span class="hljs-type">Matcher</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> p.matcher(text);<br><br><span class="hljs-keyword">if</span> (m.find()) &#123;<br><br>    System.out.println(<span class="hljs-string">&quot;匹配到的结果: &quot;</span> + m.group(<span class="hljs-number">0</span>));<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a><strong>常用方法</strong></h2><p><code>matches(String regex)</code>: 检查整个字符串是否匹配给定的正则表达式。</p><p><code>split(String regex)</code>: 使用给定的正则表达式拆分输入的字符串。</p><p> <code>replaceFirst(String regex, String replacement)</code> 和 <code>replaceAll(String regex, String replacement)</code>: 替换字符串中与正则表达式匹配的部分。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">text</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;apple,banana,orange&quot;</span>;<br><br>String[] fruits = text.split(<span class="hljs-string">&quot;,&quot;</span>);<br><br><span class="hljs-keyword">for</span> (String fruit : fruits) &#123;<br><br>    System.out.println(fruit);<br><br>&#125;<br><br><span class="hljs-type">String</span> <span class="hljs-variable">text2</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;I love apple, I eat apple everyday.&quot;</span>;<br><br><span class="hljs-type">String</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> text2.replaceAll(<span class="hljs-string">&quot;apple&quot;</span>, <span class="hljs-string">&quot;banana&quot;</span>);<br><br>System.out.println(result);<br></code></pre></td></tr></table></figure><h2 id="常见的正则表达式符号"><a href="#常见的正则表达式符号" class="headerlink" title="常见的正则表达式符号"></a><strong>常见的正则表达式符号</strong></h2><p>   <code>.</code>: 匹配任何字符</p><p>   <code>*</code>: 匹配零个或多个前面的元素</p><p>   <code>+</code>: 匹配一个或多个前面的元素</p><p>  <code>[]</code>: 匹配括号内的任意一个字符</p><p>  <code>^</code> 和 <code>$</code>: 匹配字符串的开始和结束</p><p>以上是Java中正则表达式的一些基本用法和方法，通过灵活运用正则表达式，可以实现强大的文本处理功能</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java课堂笔记 第五章 foreach语句与多维数组</title>
    <link href="/2024/03/18/Java/Java%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0%20%E7%AC%AC%E4%BA%94%E7%AB%A0%20foreach%E8%AF%AD%E5%8F%A5%E4%B8%8E%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84/"/>
    <url>/2024/03/18/Java/Java%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0%20%E7%AC%AC%E4%BA%94%E7%AB%A0%20foreach%E8%AF%AD%E5%8F%A5%E4%B8%8E%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84/</url>
    
    <content type="html"><![CDATA[<h1 id="Foreach-语句"><a href="#Foreach-语句" class="headerlink" title="Foreach 语句"></a>Foreach 语句</h1><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span>(type element:array)&#123;<br>System.out.println(element);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> ch05;<br><br><span class="hljs-keyword">import</span> java.util.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ch05</span> &#123;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><span class="hljs-comment">// TODO Auto-generated method stub</span><br>String [] myName=<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span> [] &#123;<span class="hljs-string">&quot;小明&quot;</span>,<span class="hljs-string">&quot;小红&quot;</span>,<span class="hljs-string">&quot;小刘&quot;</span>&#125;;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;myName.length;i++)<br>&#123;<br>System.out.println(myName[i]);<br>&#125;<br><span class="hljs-keyword">for</span>(String name :myName) &#123;<br>System.out.println(name);<br>&#125;<br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="弊端"><a href="#弊端" class="headerlink" title="弊端"></a>弊端</h2><p>不能对数组的原始值进行改变，只能修改提取出来之后的数据.</p><h1 id="二位数组"><a href="#二位数组" class="headerlink" title="二位数组"></a>二位数组</h1><blockquote><p>在Java中无真正的多维数组，只是数组的数组</p></blockquote><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> [ ] [ ] a=<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span> [行] [列];<br></code></pre></td></tr></table></figure><p>或者</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> [ ] [ ] a;<br><br>a=<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span> [行] [列];<br></code></pre></td></tr></table></figure><h2 id="例子-1"><a href="#例子-1" class="headerlink" title="例子"></a>例子</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> ch05;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ch053</span> &#123;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><span class="hljs-comment">// TODO Auto-generated method stub</span><br><span class="hljs-type">int</span> [][]a=<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span> [<span class="hljs-number">3</span>][<span class="hljs-number">4</span>];<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;a.length;i++) &#123;<span class="hljs-comment">//此处可以使用a的属性length进行代表行数</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;a[i].length;j++) &#123;<br>System.out.print(a[i][j]+<span class="hljs-string">&quot; &quot;</span>);<br>&#125;<br>System.out.println();<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用foreach语句进行输出</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> ch05;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ch053</span> &#123;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><span class="hljs-comment">// TODO Auto-generated method stub</span><br><span class="hljs-type">int</span> [][]a=<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span> [<span class="hljs-number">3</span>][<span class="hljs-number">4</span>];<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span>[] row : a) &#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> col : row) &#123;<br>System.out.println(col);<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>综合使用：打印杨辉三角</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> ch05;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ch054</span> &#123;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><span class="hljs-comment">// TODO Auto-generated method stub</span><br><span class="hljs-type">int</span> n=<span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> [][]a=<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span> [n][];<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;a.length;i++)&#123;<br>a[i]=<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[i+<span class="hljs-number">1</span>];<br>&#125;<br>a[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;a.length;i++) &#123;<br>a[i][<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;<br>a[i][a[i].length-<span class="hljs-number">1</span>]=<span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;a[i].length-<span class="hljs-number">1</span>;j++)<br>&#123;<br>a[i][j]=a[i-<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>]+a[i-<span class="hljs-number">1</span>][j];<br>&#125;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> [] row:a) &#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> col:row) &#123;<br>System.out.print(col+<span class="hljs-string">&quot; &quot;</span>);<br>&#125;<br>System.out.println();<br>&#125;<br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>VPS常用命令及工具备忘录</title>
    <link href="/2024/03/12/Linux/VPS%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E5%8F%8A%E5%B7%A5%E5%85%B7%E5%A4%87%E5%BF%98%E5%BD%95/"/>
    <url>/2024/03/12/Linux/VPS%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E5%8F%8A%E5%B7%A5%E5%85%B7%E5%A4%87%E5%BF%98%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h1 id="Linux更新及安装命令"><a href="#Linux更新及安装命令" class="headerlink" title="Linux更新及安装命令"></a>Linux更新及安装命令</h1><p>Debian更新：<code>apt-get update &amp;&amp; apt-get upgrade</code><br>Centos更新：<code>yum update</code></p><p>Debian安装curl：<code>apt-get install curl</code><br>Centos安装curl：<code>yum install curl</code></p><p>Debian安装wget：<code>apt-get install wget</code><br>Centos安装wget：<code>yum install wget</code></p><p>Centos安装XZ压缩工具：<code>yum install xz</code></p><h1 id="Debian-Ubuntu-基础命令"><a href="#Debian-Ubuntu-基础命令" class="headerlink" title="Debian&#x2F;Ubuntu 基础命令"></a>Debian&#x2F;Ubuntu 基础命令</h1><p>更新软件源：<code>apt-get update</code><br>更新升级所有软件：<code>apt-get upgrade</code></p><p>清理旧版本的软件缓存：<code>sudo apt-get autoclean</code><br>清理所有软件缓存：<code>sudo apt-get clean</code><br>删除系统不再使用的孤立软件：<code>sudo apt-get autoremove</code></p><p>查看内核版本：<code>uname -a</code><br>查看ubuntu版本：<code>cat /etc/issue</code></p><p>查看当前的内存使用情况：<code>free -m</code><br>查看当前有哪些进程：<code>ps -A</code><br>杀死一个进程：<code>kill id / killall id / kill -9 id</code></p><p>安装 openssh-server：<code>sudo apt-get install openssh-server</code><br>确认sshserver是否启动：<code>ps -e | grep ssh</code></p><h1 id="第三方命令"><a href="#第三方命令" class="headerlink" title="第三方命令"></a>第三方命令</h1><p>Centos安装neofetch<br>Github官网：<a href="https://github.com/dylanaraps/neofetch/wiki/Installation">https://github.com/dylanaraps/neofetch/wiki/Installation</a></p><p>Linux开启原版BBR</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;net.core.default_qdisc=fq&quot;</span> &gt;&gt; /etc/sysctl.confecho <span class="hljs-string">&quot;net.ipv4.tcp_congestion_control=bbr&quot;</span> &gt;&gt; /etc/sysctl.confsysctl -plsmod | grep bbr<br></code></pre></td></tr></table></figure><p>Linux 常用的一键脚本<br>UnixBench跑分工具测试</p><p>UnixBench下载地址：<a href="https://code.google.com/archive/p/byte-unixbench/downloads">https://code.google.com/archive/p/byte-unixbench/downloads</a></p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim">wget --<span class="hljs-keyword">no</span>-check-certificate http://tools.laobuluo.<span class="hljs-keyword">com</span>/tools/unixbench.shchmod +<span class="hljs-keyword">x</span> unixbench.<span class="hljs-keyword">sh</span>./unixbench.<span class="hljs-keyword">sh</span><br></code></pre></td></tr></table></figure><p><a href="http://bench.sh/">bench.sh</a> 测速脚本</p><p>Github地址：<a href="https://github.com/teddysun/across">https://github.com/teddysun/across</a></p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey">wget -qO- bench.sh | bash`或者`curl -Lso- bench.sh | bash<br></code></pre></td></tr></table></figure><p>BestTrace 路由追踪</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">wget https://cdn.ipip.net/17mon/besttrace4linux.zipunzip besttrace4linux.zipchmod +x besttrace./besttrace 114.114.114.114<br></code></pre></td></tr></table></figure><p>流媒体解锁检测脚本</p><p>Github地址：<a href="https://github.com/sjlleo/netflix-verify%EF%BF%BCNetflix">https://github.com/sjlleo/netflix-verify<br>Netflix</a> 解锁检测脚本</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">wget -O nf https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/sjlleo/</span>netflix-verify<span class="hljs-regexp">/releases/</span>download<span class="hljs-regexp">/2.61/</span>nf_2.<span class="hljs-number">61</span>_linux_amd64 &amp;&amp; chmod +x nf &amp;&amp; clear &amp;&amp; ./nf<br></code></pre></td></tr></table></figure><p>一键DD纯净系统脚本(萌咖) CentOS&#x2F;Debian&#x2F;Ubuntu</p><p>系统安装完成后的默认用户名为root，默认密码为: <a href="http://moeclub.org/">MoeClub.org</a></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">bash</span> &lt;(wget --no-check-certificate -qO- &#x27;https://www.moeelf.com/attachment/LinuxShell/InstallNET.sh&#x27;) -d <span class="hljs-number">11</span> -v <span class="hljs-number">64</span> -a # Debian <span class="hljs-number">11</span> <span class="hljs-number">64</span>位<br><span class="hljs-attribute">bash</span> &lt;(wget --no-check-certificate -qO- &#x27;https://www.moeelf.com/attachment/LinuxShell/InstallNET.sh&#x27;) -u <span class="hljs-number">20</span>.<span class="hljs-number">04</span> -v <span class="hljs-number">64</span> -a # Ubuntu <span class="hljs-number">20</span>.<span class="hljs-number">04</span> <span class="hljs-number">64</span>位<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Command</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java课堂笔记 第五章 一维数组</title>
    <link href="/2024/03/12/Java/Java%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0%20%E7%AC%AC%E4%BA%94%E7%AB%A0%20%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84/"/>
    <url>/2024/03/12/Java/Java%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0%20%E7%AC%AC%E4%BA%94%E7%AB%A0%20%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84/</url>
    
    <content type="html"><![CDATA[<h1 id="一维数组"><a href="#一维数组" class="headerlink" title="一维数组"></a>一维数组</h1><h2 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h2><ol><li>声明数组</li><li>分配空间</li><li>创建数组元素并赋值</li></ol><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs haxe">数据类型[] 数组名称  <span class="hljs-comment">//声明一维数组</span><br>数组名= <span class="hljs-keyword">new</span> <span class="hljs-type"></span>数据类型[个数] <span class="hljs-comment">//动态分配内存给数组</span><br></code></pre></td></tr></table></figure><p>e.g.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> [ ] x; <span class="hljs-comment">//声明名称为x的int型数组，未分配内存给数组</span><br><br>x= <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">10</span>];  <span class="hljs-comment">//x中包含有10个元素，并分配空间</span><br></code></pre></td></tr></table></figure><p>或者<br>数据类型[ ] 数组名&#x3D;new 数据类型 [个数]</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> [ ] x =<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span> [<span class="hljs-number">10</span>];<br></code></pre></td></tr></table></figure><h3 id="举例子"><a href="#举例子" class="headerlink" title="举例子"></a>举例子</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> shuzu;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">shuzu</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">int</span>[] x = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">10</span>];<br>        x[<span class="hljs-number">1</span>] = <span class="hljs-number">10</span>;<br>        System.out.println(x[<span class="hljs-number">1</span>]);<br>        <br>        <span class="hljs-type">int</span> [] a=<span class="hljs-literal">null</span>;<br>        a=<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span> [<span class="hljs-number">10</span>];<br>        System.out.println(a);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;a.length;i++) &#123;<br>        a[i]=i;<br>        System.out.println(a[i]);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java课堂笔记 第四章 If语句</title>
    <link href="/2024/03/11/Java/Java%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0%20%E7%AC%AC%E5%9B%9B%E7%AB%A0%20If%E8%AF%AD%E5%8F%A5/"/>
    <url>/2024/03/11/Java/Java%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0%20%E7%AC%AC%E5%9B%9B%E7%AB%A0%20If%E8%AF%AD%E5%8F%A5/</url>
    
    <content type="html"><![CDATA[<h1 id="分支结构"><a href="#分支结构" class="headerlink" title="分支结构"></a>分支结构</h1><p>if(  )里面的表达式的结果必须是布尔型</p><h2 id="If语句例题"><a href="#If语句例题" class="headerlink" title="If语句例题"></a>If语句例题</h2><p>判断3个坐标是否可以构建成三角形</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> javaapp3;<br><span class="hljs-keyword">import</span> java.io.*;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Javaapp3</span> &#123;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br><br>        <span class="hljs-type">double</span> x1,y1;<br>        <span class="hljs-type">double</span> x2,y2;<br>        <span class="hljs-type">double</span> x3,y3;<br>        <br>        <span class="hljs-type">BufferedReader</span> <span class="hljs-variable">buf</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InputStreamReader</span>(System.in));<br><br>        String str=buf.readLine();<br>        x1=Double.parseDouble(str);<br>        str=buf.readLine();<br>        y1=Double.parseDouble(str);<br>        str=buf.readLine();<br>        x2=Double.parseDouble(str);<br>        str=buf.readLine();<br>        y2=Double.parseDouble(str);<br>        str=buf.readLine();<br>        x3=Double.parseDouble(str);<br>        str=buf.readLine();<br>        y3=Double.parseDouble(str);<br>        <br>        <span class="hljs-type">double</span> d1,d2,d3;<br>        d1=Math.sqrt(Math.pow((x1-x2),<span class="hljs-number">2</span>)+Math.pow((y1-y2),<span class="hljs-number">2</span>));<br>        d2=Math.sqrt(Math.pow((x1-x3),<span class="hljs-number">2</span>)+Math.pow((y1-y3),<span class="hljs-number">2</span>));<br>        d3=Math.sqrt(Math.pow((x3-x2),<span class="hljs-number">2</span>)+Math.pow((y3-y2),<span class="hljs-number">2</span>));<br>        <br>        <span class="hljs-keyword">if</span>(d1+d2&gt;d3&amp;&amp;d2+d3&gt;d1&amp;&amp;d1+d3&gt;d2)<br>        &#123;<br>        System.out.println(<span class="hljs-string">&quot;OK&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>        System.out.println(<span class="hljs-string">&quot;NO&quot;</span>);<br>        &#125;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java课堂笔记 第三章 数据类型</title>
    <link href="/2024/03/11/Java/Java%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0%20%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    <url>/2024/03/11/Java/Java%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0%20%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h1><p>浮点数不能使用“&#x3D;&#x3D;”运算符进行判断</p><h1 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h1><p><img src="https://img.lammy.top/file/b1f3ba205aa59a69eda40.png" alt="img"></p><h1 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h1><h1 id=""><a href="#" class="headerlink" title=""></a><img src="https://img.lammy.top/file/8ccfc06d3cca089f1cb03.png" alt="img"></h1><h1 id="条件运算符"><a href="#条件运算符" class="headerlink" title="条件运算符"></a>条件运算符</h1><h1 id="ACM"><a href="#ACM" class="headerlink" title="ACM"></a><img src="https://img.lammy.top/file/25f939de2656fd730882b.png" alt="img">ACM</h1><h1 id="语句与复合语句"><a href="#语句与复合语句" class="headerlink" title="语句与复合语句"></a><img src="https://img.lammy.top/file/0ad5eeac191463d086857.png" alt="img">语句与复合语句</h1><p><img src="https://img.lammy.top/file/abd2aeaa539168c1e4635.png" alt="img"></p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java课堂笔记 第三章 环境的配置以及第一个程序</title>
    <link href="/2024/03/09/Java/Java%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0%20%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E7%8E%AF%E5%A2%83%E7%9A%84%E9%85%8D%E7%BD%AE%E4%BB%A5%E5%8F%8A%E7%AC%AC%E4%B8%80%E4%B8%AA%E7%A8%8B%E5%BA%8F/"/>
    <url>/2024/03/09/Java/Java%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0%20%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E7%8E%AF%E5%A2%83%E7%9A%84%E9%85%8D%E7%BD%AE%E4%BB%A5%E5%8F%8A%E7%AC%AC%E4%B8%80%E4%B8%AA%E7%A8%8B%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<blockquote><p>之前的博客因为玩不懂 Docker 的备份，数据丢失，TAT</p></blockquote><p>第一周学的是 Java 的环境配置，这里就顺带提一下吧。</p><h1 id="Java-环境配置"><a href="#Java-环境配置" class="headerlink" title="Java 环境配置"></a>Java 环境配置</h1><ol><li>打开控制面板的 – 系统与安全 – 系统 – 高级系统设置 – 环境变量</li></ol><p>在下方的系统变量找到 Path，点击新加，把 JDK 目录下的 bin 目录路径写进去。</p><p>我这里是 D:\javajdk21\bin，你需要找到你的 JDK 安装到了哪里。</p><p>Path添加</p><p><img src="https://img.lammy.top/file/33b278dd0451c0b113914.png" alt="img"></p><ol start="2"><li>第二步是配置 ClassPath</li></ol><p>这里是配置两个，一个是” . “，另外一个是“jdk&#x2F;lib” 的路径。</p><p>ClassPath配置</p><p><img src="https://img.lammy.top/file/49f937dbcaeedebab29aa.png" alt="img"></p><p>调用 cmd 进行查看环境是否配置完成：</p><p>分别输入 java 和 javac 看看是否提示使用方法，如果提示找不到则配置未成功。</p><h1 id="第-3-章-Java-语言基础"><a href="#第-3-章-Java-语言基础" class="headerlink" title="第 3 章 Java 语言基础"></a>第 3 章 Java 语言基础</h1><p>书上的数据类型和数据赋值等就不学了，C 语言有的学。</p><h2 id="数据类型的转换"><a href="#数据类型的转换" class="headerlink" title="数据类型的转换"></a>数据类型的转换</h2><p>数据类型优先级，从左到右从低到高</p><p>运用：当两个数进行运算时候，系统会把低级的数往高级的数进行转换计算</p><h2 id="数据类型转换语法"><a href="#数据类型转换语法" class="headerlink" title="数据类型转换语法"></a>数据类型转换语法</h2><p>他的语法和 C 语言的有相似之处：</p><p>举例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">float</span> a=<span class="hljs-number">2.2</span>;<br><br><span class="hljs-type">int</span> b=<span class="hljs-number">0</span>;<br><br>b=(<span class="hljs-type">int</span>)a;<br></code></pre></td></tr></table></figure><p>这样子就会把 a 从浮点数强制转换成了整型</p><h2 id="局部变量与成员变量"><a href="#局部变量与成员变量" class="headerlink" title="局部变量与成员变量"></a>局部变量与成员变量</h2><p>成员变量是在 类 中定义的变量</p><p>局部变量是在 方法 中定义的变量</p><p>类中的成员变量相当于 C 语言里面的全局变量</p><p>而局部变量就相当于 C 语言里面的子函数里面的变量</p><p>故名思意，他们是有他们的作用范围的，成员变量可以被任何在类下的方法进行调用，而局部变量只能在对应的、方法里面进行调用</p><h3 id="Var-的使用"><a href="#Var-的使用" class="headerlink" title="Var 的使用"></a>Var 的使用</h3><p>Var 只能声明局部变量，而不能声明方法的参数类型，返回值类型或者类的实例变量。</p><p>使用 var 每次只能声明一个变量。</p><p>不能使用 null 作为初始值。</p><p>看着好像很多限制哦，不知道发明他干什么。</p><p>例子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">b</span>&#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br><br>        <span class="hljs-keyword">var</span> a=<span class="hljs-number">10</span>;<br><br>        System.out.println(a);<br><br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>没有问题的话输出应该是 10</p><p>这个 var 定义的的话有什么好处呢？好像可以不用框死数据的类型，可以使用在那种不知道将会有什么值赋过来的情形。（个人的想法）</p><h2 id="从键盘输入数据"><a href="#从键盘输入数据" class="headerlink" title="从键盘输入数据"></a>从键盘输入数据</h2><p>这里老师讲了两种方法：</p><h3 id="使用-io-库的键盘输入"><a href="#使用-io-库的键盘输入" class="headerlink" title="使用 io 库的键盘输入"></a>使用 io 库的键盘输入</h3><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">b</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>        BufferedReader buf;<br><br>        buf = <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InputStreamReader</span>(System.in));<br><br>        a = Integer.parseInt(buf.readLine());<br><br>        System.out.println(a);<br><br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>这里逐渐变得抽象起来了 23333</p><p>解释一下吧，这个 BufferedReader 是搭配这个 IO 输入输出库进行使用的，格式的话就是那三行，通用的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">BufferedReader buf;<br><br>        buf = <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InputStreamReader</span>(System.in));<br><br>        a = Integer.parseInt(buf.readLine());<br></code></pre></td></tr></table></figure><p>注意这里的 a &#x3D; Integer.parseInt(buf.readLine());，这个是整数的输入方法，如果是字符串的话就使用 a &#x3D; buf.readLine();就可以了，但是他只能这样子读取字符串，所以我们需要使用转换语句将他转换成我们的整型。</p><p>这里的 throws IOException 是错误抛出使用的，如果不写的话编译器会叫你写，23333，这么比 C 语言复杂那么多。</p><p>然后的话就差不多了，多练习一下就可以记住了</p><p>其他的转换方法见书的 3.6 表</p><h4 id="课堂实操代码"><a href="#课堂实操代码" class="headerlink" title="课堂实操代码"></a>课堂实操代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">a</span>&#123;<br><br>               <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span><span class="hljs-keyword">throws</span> IOException&#123;<br><br>        String str=<span class="hljs-string">&quot;&quot;</span>;<br><br>        InputStreamReader isr=<span class="hljs-keyword">new</span> <span class="hljs-title class_">InputStreamReader</span>(System.in);<br><br>        BufferedReader buf=<span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(isr);<br><br>        str= buf.readLine();<br><br>        System.out.println(<span class="hljs-string">&quot;Your input is:&quot;</span>+str);<br><br>        String s1=<span class="hljs-string">&quot;&quot;</span>,s2=<span class="hljs-string">&quot;&quot;</span>;<br><br>        s1=buf.readLine();<br><br>        <span class="hljs-type">int</span> m1=Integer.parseInt(s1);<br><br>        s2=buf.readLine();<br><br>        <span class="hljs-type">int</span> m2=Integer.parseInt(s2);<br><br>        <span class="hljs-type">int</span> sum=m1+m2;<br><br>        System.out.println(sum);<br><br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="使用-util-库的-Scanner"><a href="#使用-util-库的-Scanner" class="headerlink" title="使用 util 库的 Scanner"></a>使用 util 库的 Scanner</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Scanner;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ScannerDemo</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">scan</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br><br>        <span class="hljs-comment">// 从键盘接收数据</span><br><br>        <span class="hljs-comment">// next 方式接收字符串</span><br><br>        System.out.println(<span class="hljs-string">&quot;next 方式接收：&quot;</span>);<br><br>        <span class="hljs-comment">// 判断是否还有输入</span><br><br>        <span class="hljs-keyword">if</span> (scan.hasNext()) &#123;<br><br>            <span class="hljs-type">String</span> <span class="hljs-variable">str1</span> <span class="hljs-operator">=</span> scan.next();<br><br>            System.out.println(<span class="hljs-string">&quot; 输入的数据为：&quot;</span> + str1);<br><br>        &#125;<br><br>        scan.close();<br><br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
